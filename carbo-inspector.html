<html><head><meta charset="UTF-8"><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><link rel="import" href="../polymer/polymer.html">
<style is="custom-style">:root {/* Material Design color palette for Google products */--google-red-100: #f4c7c3;--google-red-300: #e67c73;--google-red-500: #db4437;--google-red-700: #c53929;--google-blue-100: #c6dafc;--google-blue-300: #7baaf7;--google-blue-500: #4285f4;--google-blue-700: #3367d6;--google-green-100: #b7e1cd;--google-green-300: #57bb8a;--google-green-500: #0f9d58;--google-green-700: #0b8043;--google-yellow-100: #fce8b2;--google-yellow-300: #f7cb4d;--google-yellow-500: #f4b400;--google-yellow-700: #f09300;--google-grey-100: #f5f5f5;--google-grey-300: #e0e0e0;--google-grey-500: #9e9e9e;--google-grey-700: #616161;/* Material Design color palette from online spec document */--paper-red-50: #ffebee;--paper-red-100: #ffcdd2;--paper-red-200: #ef9a9a;--paper-red-300: #e57373;--paper-red-400: #ef5350;--paper-red-500: #f44336;--paper-red-600: #e53935;--paper-red-700: #d32f2f;--paper-red-800: #c62828;--paper-red-900: #b71c1c;--paper-red-a100: #ff8a80;--paper-red-a200: #ff5252;--paper-red-a400: #ff1744;--paper-red-a700: #d50000;--paper-pink-50: #fce4ec;--paper-pink-100: #f8bbd0;--paper-pink-200: #f48fb1;--paper-pink-300: #f06292;--paper-pink-400: #ec407a;--paper-pink-500: #e91e63;--paper-pink-600: #d81b60;--paper-pink-700: #c2185b;--paper-pink-800: #ad1457;--paper-pink-900: #880e4f;--paper-pink-a100: #ff80ab;--paper-pink-a200: #ff4081;--paper-pink-a400: #f50057;--paper-pink-a700: #c51162;--paper-purple-50: #f3e5f5;--paper-purple-100: #e1bee7;--paper-purple-200: #ce93d8;--paper-purple-300: #ba68c8;--paper-purple-400: #ab47bc;--paper-purple-500: #9c27b0;--paper-purple-600: #8e24aa;--paper-purple-700: #7b1fa2;--paper-purple-800: #6a1b9a;--paper-purple-900: #4a148c;--paper-purple-a100: #ea80fc;--paper-purple-a200: #e040fb;--paper-purple-a400: #d500f9;--paper-purple-a700: #aa00ff;--paper-deep-purple-50: #ede7f6;--paper-deep-purple-100: #d1c4e9;--paper-deep-purple-200: #b39ddb;--paper-deep-purple-300: #9575cd;--paper-deep-purple-400: #7e57c2;--paper-deep-purple-500: #673ab7;--paper-deep-purple-600: #5e35b1;--paper-deep-purple-700: #512da8;--paper-deep-purple-800: #4527a0;--paper-deep-purple-900: #311b92;--paper-deep-purple-a100: #b388ff;--paper-deep-purple-a200: #7c4dff;--paper-deep-purple-a400: #651fff;--paper-deep-purple-a700: #6200ea;--paper-indigo-50: #e8eaf6;--paper-indigo-100: #c5cae9;--paper-indigo-200: #9fa8da;--paper-indigo-300: #7986cb;--paper-indigo-400: #5c6bc0;--paper-indigo-500: #3f51b5;--paper-indigo-600: #3949ab;--paper-indigo-700: #303f9f;--paper-indigo-800: #283593;--paper-indigo-900: #1a237e;--paper-indigo-a100: #8c9eff;--paper-indigo-a200: #536dfe;--paper-indigo-a400: #3d5afe;--paper-indigo-a700: #304ffe;--paper-blue-50: #e3f2fd;--paper-blue-100: #bbdefb;--paper-blue-200: #90caf9;--paper-blue-300: #64b5f6;--paper-blue-400: #42a5f5;--paper-blue-500: #2196f3;--paper-blue-600: #1e88e5;--paper-blue-700: #1976d2;--paper-blue-800: #1565c0;--paper-blue-900: #0d47a1;--paper-blue-a100: #82b1ff;--paper-blue-a200: #448aff;--paper-blue-a400: #2979ff;--paper-blue-a700: #2962ff;--paper-light-blue-50: #e1f5fe;--paper-light-blue-100: #b3e5fc;--paper-light-blue-200: #81d4fa;--paper-light-blue-300: #4fc3f7;--paper-light-blue-400: #29b6f6;--paper-light-blue-500: #03a9f4;--paper-light-blue-600: #039be5;--paper-light-blue-700: #0288d1;--paper-light-blue-800: #0277bd;--paper-light-blue-900: #01579b;--paper-light-blue-a100: #80d8ff;--paper-light-blue-a200: #40c4ff;--paper-light-blue-a400: #00b0ff;--paper-light-blue-a700: #0091ea;--paper-cyan-50: #e0f7fa;--paper-cyan-100: #b2ebf2;--paper-cyan-200: #80deea;--paper-cyan-300: #4dd0e1;--paper-cyan-400: #26c6da;--paper-cyan-500: #00bcd4;--paper-cyan-600: #00acc1;--paper-cyan-700: #0097a7;--paper-cyan-800: #00838f;--paper-cyan-900: #006064;--paper-cyan-a100: #84ffff;--paper-cyan-a200: #18ffff;--paper-cyan-a400: #00e5ff;--paper-cyan-a700: #00b8d4;--paper-teal-50: #e0f2f1;--paper-teal-100: #b2dfdb;--paper-teal-200: #80cbc4;--paper-teal-300: #4db6ac;--paper-teal-400: #26a69a;--paper-teal-500: #009688;--paper-teal-600: #00897b;--paper-teal-700: #00796b;--paper-teal-800: #00695c;--paper-teal-900: #004d40;--paper-teal-a100: #a7ffeb;--paper-teal-a200: #64ffda;--paper-teal-a400: #1de9b6;--paper-teal-a700: #00bfa5;--paper-green-50: #e8f5e9;--paper-green-100: #c8e6c9;--paper-green-200: #a5d6a7;--paper-green-300: #81c784;--paper-green-400: #66bb6a;--paper-green-500: #4caf50;--paper-green-600: #43a047;--paper-green-700: #388e3c;--paper-green-800: #2e7d32;--paper-green-900: #1b5e20;--paper-green-a100: #b9f6ca;--paper-green-a200: #69f0ae;--paper-green-a400: #00e676;--paper-green-a700: #00c853;--paper-light-green-50: #f1f8e9;--paper-light-green-100: #dcedc8;--paper-light-green-200: #c5e1a5;--paper-light-green-300: #aed581;--paper-light-green-400: #9ccc65;--paper-light-green-500: #8bc34a;--paper-light-green-600: #7cb342;--paper-light-green-700: #689f38;--paper-light-green-800: #558b2f;--paper-light-green-900: #33691e;--paper-light-green-a100: #ccff90;--paper-light-green-a200: #b2ff59;--paper-light-green-a400: #76ff03;--paper-light-green-a700: #64dd17;--paper-lime-50: #f9fbe7;--paper-lime-100: #f0f4c3;--paper-lime-200: #e6ee9c;--paper-lime-300: #dce775;--paper-lime-400: #d4e157;--paper-lime-500: #cddc39;--paper-lime-600: #c0ca33;--paper-lime-700: #afb42b;--paper-lime-800: #9e9d24;--paper-lime-900: #827717;--paper-lime-a100: #f4ff81;--paper-lime-a200: #eeff41;--paper-lime-a400: #c6ff00;--paper-lime-a700: #aeea00;--paper-yellow-50: #fffde7;--paper-yellow-100: #fff9c4;--paper-yellow-200: #fff59d;--paper-yellow-300: #fff176;--paper-yellow-400: #ffee58;--paper-yellow-500: #ffeb3b;--paper-yellow-600: #fdd835;--paper-yellow-700: #fbc02d;--paper-yellow-800: #f9a825;--paper-yellow-900: #f57f17;--paper-yellow-a100: #ffff8d;--paper-yellow-a200: #ffff00;--paper-yellow-a400: #ffea00;--paper-yellow-a700: #ffd600;--paper-amber-50: #fff8e1;--paper-amber-100: #ffecb3;--paper-amber-200: #ffe082;--paper-amber-300: #ffd54f;--paper-amber-400: #ffca28;--paper-amber-500: #ffc107;--paper-amber-600: #ffb300;--paper-amber-700: #ffa000;--paper-amber-800: #ff8f00;--paper-amber-900: #ff6f00;--paper-amber-a100: #ffe57f;--paper-amber-a200: #ffd740;--paper-amber-a400: #ffc400;--paper-amber-a700: #ffab00;--paper-orange-50: #fff3e0;--paper-orange-100: #ffe0b2;--paper-orange-200: #ffcc80;--paper-orange-300: #ffb74d;--paper-orange-400: #ffa726;--paper-orange-500: #ff9800;--paper-orange-600: #fb8c00;--paper-orange-700: #f57c00;--paper-orange-800: #ef6c00;--paper-orange-900: #e65100;--paper-orange-a100: #ffd180;--paper-orange-a200: #ffab40;--paper-orange-a400: #ff9100;--paper-orange-a700: #ff6500;--paper-deep-orange-50: #fbe9e7;--paper-deep-orange-100: #ffccbc;--paper-deep-orange-200: #ffab91;--paper-deep-orange-300: #ff8a65;--paper-deep-orange-400: #ff7043;--paper-deep-orange-500: #ff5722;--paper-deep-orange-600: #f4511e;--paper-deep-orange-700: #e64a19;--paper-deep-orange-800: #d84315;--paper-deep-orange-900: #bf360c;--paper-deep-orange-a100: #ff9e80;--paper-deep-orange-a200: #ff6e40;--paper-deep-orange-a400: #ff3d00;--paper-deep-orange-a700: #dd2c00;--paper-brown-50: #efebe9;--paper-brown-100: #d7ccc8;--paper-brown-200: #bcaaa4;--paper-brown-300: #a1887f;--paper-brown-400: #8d6e63;--paper-brown-500: #795548;--paper-brown-600: #6d4c41;--paper-brown-700: #5d4037;--paper-brown-800: #4e342e;--paper-brown-900: #3e2723;--paper-grey-50: #fafafa;--paper-grey-100: #f5f5f5;--paper-grey-200: #eeeeee;--paper-grey-300: #e0e0e0;--paper-grey-400: #bdbdbd;--paper-grey-500: #9e9e9e;--paper-grey-600: #757575;--paper-grey-700: #616161;--paper-grey-800: #424242;--paper-grey-900: #212121;--paper-blue-grey-50: #eceff1;--paper-blue-grey-100: #cfd8dc;--paper-blue-grey-200: #b0bec5;--paper-blue-grey-300: #90a4ae;--paper-blue-grey-400: #78909c;--paper-blue-grey-500: #607d8b;--paper-blue-grey-600: #546e7a;--paper-blue-grey-700: #455a64;--paper-blue-grey-800: #37474f;--paper-blue-grey-900: #263238;/* opacity for dark text on a light background */--dark-divider-opacity: 0.12;--dark-disabled-opacity: 0.26; /* or hint text */--dark-secondary-opacity: 0.54; /* or icon */--dark-primary-opacity: 0.87;/* opacity for light text on a dark background */--light-divider-opacity: 0.12;--light-disabled-opacity: 0.3; /* or hint text */--light-secondary-opacity: 0.7; /* or icon */--light-primary-opacity: 1.0;}</style>
<style>/* IE 10 support for HTML5 hidden attr */[hidden] {display: none !important;}</style>

<style is="custom-style">:root {--layout: {display: -ms-flexbox;display: -webkit-flex;display: flex;};--layout-inline: {display: -ms-inline-flexbox;display: -webkit-inline-flex;display: inline-flex;};--layout-horizontal: {/* @apply(--layout); */display: -ms-flexbox;display: -webkit-flex;display: flex;-ms-flex-direction: row;-webkit-flex-direction: row;flex-direction: row;};--layout-horizontal-reverse: {-ms-flex-direction: row-reverse;-webkit-flex-direction: row-reverse;flex-direction: row-reverse;};--layout-vertical: {/* @apply(--layout); */display: -ms-flexbox;display: -webkit-flex;display: flex;-ms-flex-direction: column;-webkit-flex-direction: column;flex-direction: column;};--layout-vertical-reverse: {-ms-flex-direction: column-reverse;-webkit-flex-direction: column-reverse;flex-direction: column-reverse;};--layout-wrap: {-ms-flex-wrap: wrap;-webkit-flex-wrap: wrap;flex-wrap: wrap;};--layout-wrap-reverse: {-ms-flex-wrap: wrap-reverse;-webkit-flex-wrap: wrap-reverse;flex-wrap: wrap-reverse;};--layout-flex-auto: {-ms-flex: 1 1 auto;-webkit-flex: 1 1 auto;flex: 1 1 auto;};--layout-flex-none: {-ms-flex: none;-webkit-flex: none;flex: none;};--layout-flex: {-ms-flex: 1 1 0.000000001px;-webkit-flex: 1;flex: 1;-webkit-flex-basis: 0.000000001px;flex-basis: 0.000000001px;};--layout-flex-2: {-ms-flex: 2;-webkit-flex: 2;flex: 2;};--layout-flex-3: {-ms-flex: 3;-webkit-flex: 3;flex: 3;};--layout-flex-4: {-ms-flex: 4;-webkit-flex: 4;flex: 4;};--layout-flex-5: {-ms-flex: 5;-webkit-flex: 5;flex: 5;};--layout-flex-6: {-ms-flex: 6;-webkit-flex: 6;flex: 6;};--layout-flex-7: {-ms-flex: 7;-webkit-flex: 7;flex: 7;};--layout-flex-8: {-ms-flex: 8;-webkit-flex: 8;flex: 8;};--layout-flex-9: {-ms-flex: 9;-webkit-flex: 9;flex: 9;};--layout-flex-10: {-ms-flex: 10;-webkit-flex: 10;flex: 10;};--layout-flex-11: {-ms-flex: 11;-webkit-flex: 11;flex: 11;};--layout-flex-12: {-ms-flex: 12;-webkit-flex: 12;flex: 12;};/* alignment in cross axis */--layout-start: {-ms-flex-align: start;-webkit-align-items: flex-start;align-items: flex-start;};--layout-center: {-ms-flex-align: center;-webkit-align-items: center;align-items: center;};--layout-end: {-ms-flex-align: end;-webkit-align-items: flex-end;align-items: flex-end;};/* alignment in main axis */--layout-start-justified: {-ms-flex-pack: start;-webkit-justify-content: flex-start;justify-content: flex-start;};--layout-center-justified: {-ms-flex-pack: center;-webkit-justify-content: center;justify-content: center;};--layout-end-justified: {-ms-flex-pack: end;-webkit-justify-content: flex-end;justify-content: flex-end;};--layout-around-justified: {-ms-flex-pack: around;-webkit-justify-content: space-around;justify-content: space-around;};--layout-justified: {-ms-flex-pack: justify;-webkit-justify-content: space-between;justify-content: space-between;};--layout-center-center: {/* @apply(--layout-center --layout-center-justified); */-ms-flex-align: center;-webkit-align-items: center;align-items: center;-ms-flex-pack: center;-webkit-justify-content: center;justify-content: center;};/* self alignment */--layout-self-start: {-ms-align-self: flex-start;-webkit-align-self: flex-start;align-self: flex-start;};--layout-self-center: {-ms-align-self: center;-webkit-align-self: center;align-self: center;};--layout-self-end: {-ms-align-self: flex-end;-webkit-align-self: flex-end;align-self: flex-end;};--layout-self-stretch: {-ms-align-self: stretch;-webkit-align-self: stretch;align-self: stretch;};/*******************************Other Layout*******************************/--layout-block: {display: block;};--layout-invisible: {visibility: hidden !important;};--layout-relative: {position: relative;};--layout-fit: {position: absolute;top: 0;right: 0;bottom: 0;left: 0;};--layout-scroll: {-webkit-overflow-scrolling: touch;overflow: auto;};/* fixed position */--layout-fixed-top: {position: fixed;top: 0;left: 0;right: 0;};--layout-fixed-right: {position: fixed;top: 0;right: 0;bottom: 0;};--layout-fixed-bottom: {position: fixed;right: 0;bottom: 0;left: 0;};--layout-fixed-left: {position: fixed;top: 0;bottom: 0;left: 0;};}</style>


<link rel="import" href="../carbo-highlighter/carbo-highlighter.html">
</head><body><div hidden="" by-vulcanize=""><dom-module id="paper-spinner" assetpath="../paper-spinner/">

  <style>/**@licenseCopyright (c) 2015 The Polymer Project Authors. All rights reserved.This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txtThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txtThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txtCode distributed by Google as part of the polymer project is alsosubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt*//**************************//* STYLES FOR THE SPINNER *//**************************//* * Constants: *STROKEWIDTH = 3px *ARCSIZE= 270 degrees (amount of circle the arc takes up) *ARCTIME= 1333ms (time it takes to expand and contract arc) *ARCSTARTROT = 216 degrees (how much the start location of the arc *should rotate each time, 216 gives us a *5 pointed star shape (it's 360/5 * 3). *For a 7 pointed star, we might do *360/7 * 3 = 154.286) *CONTAINERWIDTH = 28px *SHRINK_TIME = 400ms */:host {display: inline-block;position: relative;width: 28px; /* CONTAINERWIDTH */height: 28px; /* CONTAINERWIDTH */}#spinnerContainer {width: 100%;height: 100%;/* The spinner does not have any contents that would have to be* flipped if the direction changes. Always use ltr so that the* style works out correctly in both cases. */direction: ltr;}#spinnerContainer.active {/* duration: 360 * ARCTIME / (ARCSTARTROT + (360-ARCSIZE)) */-webkit-animation: container-rotate 1568ms linear infinite;animation: container-rotate 1568ms linear infinite;}@-webkit-keyframes container-rotate {to { -webkit-transform: rotate(360deg) }}@keyframes container-rotate {to { transform: rotate(360deg) }}.spinner-layer {position: absolute;width: 100%;height: 100%;opacity: 0;}.layer-1 {border-color: var(--paper-spinner-layer-1-color, --google-blue-500);}.layer-2 {border-color: var(--paper-spinner-layer-2-color, --google-red-500);}.layer-3 {border-color: var(--paper-spinner-layer-3-color, --google-yellow-500);}.layer-4 {border-color: var(--paper-spinner-layer-4-color, --google-blue-500);}/** * IMPORTANT NOTE ABOUT CSS ANIMATION PROPERTIES (keanulee): * * iOS Safari (tested on iOS 8.1) does not handle animation-delay very well - it doesn't * guarantee that the animation will start _exactly_ after that value. So we avoid using * animation-delay and instead set custom keyframes for each color (as layer-2undant as it * seems). * * We write out each animation in full (instead of separating animation-name, * animation-duration, etc.) because under the polyfill, Safari does not recognize those * specific properties properly, treats them as -webkit-animation, and overrides the * other animation rules. See https://github.com/Polymer/platform/issues/53. */.active .spinner-layer.layer-1 {/* durations: 4 * ARCTIME */-webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-1-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-1-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;}.active .spinner-layer.layer-2 {/* durations: 4 * ARCTIME */-webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-2-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-2-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;}.active .spinner-layer.layer-3 {/* durations: 4 * ARCTIME */-webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-3-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-3-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;}.active .spinner-layer.layer-4 {/* durations: 4 * ARCTIME */-webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-4-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-4-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;}@-webkit-keyframes fill-unfill-rotate {12.5% { -webkit-transform: rotate(135deg);} /* 0.5 * ARCSIZE */25%{ -webkit-transform: rotate(270deg);} /* 1* ARCSIZE */37.5% { -webkit-transform: rotate(405deg);} /* 1.5 * ARCSIZE */50%{ -webkit-transform: rotate(540deg);} /* 2* ARCSIZE */62.5% { -webkit-transform: rotate(675deg);} /* 2.5 * ARCSIZE */75%{ -webkit-transform: rotate(810deg);} /* 3* ARCSIZE */87.5% { -webkit-transform: rotate(945deg);} /* 3.5 * ARCSIZE */to{ -webkit-transform: rotate(1080deg); } /* 4* ARCSIZE */}@keyframes fill-unfill-rotate {12.5% { transform: rotate(135deg);} /* 0.5 * ARCSIZE */25%{ transform: rotate(270deg);} /* 1* ARCSIZE */37.5% { transform: rotate(405deg);} /* 1.5 * ARCSIZE */50%{ transform: rotate(540deg);} /* 2* ARCSIZE */62.5% { transform: rotate(675deg);} /* 2.5 * ARCSIZE */75%{ transform: rotate(810deg);} /* 3* ARCSIZE */87.5% { transform: rotate(945deg);} /* 3.5 * ARCSIZE */to{ transform: rotate(1080deg); } /* 4* ARCSIZE */}/** * HACK: Even though the intention is to have the current .spinner-layer at * `opacity: 1`, we set it to `opacity: 0.99` instead since this forces Chrome * to do proper subpixel rendering for the elements being animated. This is * especially visible in Chrome 39 on Ubuntu 14.04. See: * * - https://github.com/Polymer/paper-spinner/issues/9 * - https://code.google.com/p/chromium/issues/detail?id=436255 */@-webkit-keyframes layer-1-fade-in-out {from { opacity: 0.99; }25% { opacity: 0.99; }26% { opacity: 0; }89% { opacity: 0; }90% { opacity: 0.99; }100% { opacity: 0.99; }}@keyframes layer-1-fade-in-out {from { opacity: 0.99; }25% { opacity: 0.99; }26% { opacity: 0; }89% { opacity: 0; }90% { opacity: 0.99; }100% { opacity: 0.99; }}@-webkit-keyframes layer-2-fade-in-out {from { opacity: 0; }15% { opacity: 0; }25% { opacity: 0.99; }50% { opacity: 0.99; }51% { opacity: 0; }}@keyframes layer-2-fade-in-out {from { opacity: 0; }15% { opacity: 0; }25% { opacity: 0.99; }50% { opacity: 0.99; }51% { opacity: 0; }}@-webkit-keyframes layer-3-fade-in-out {from { opacity: 0; }40% { opacity: 0; }50% { opacity: 0.99; }75% { opacity: 0.99; }76% { opacity: 0; }}@keyframes layer-3-fade-in-out {from { opacity: 0; }40% { opacity: 0; }50% { opacity: 0.99; }75% { opacity: 0.99; }76% { opacity: 0; }}@-webkit-keyframes layer-4-fade-in-out {from { opacity: 0; }65% { opacity: 0; }75% { opacity: 0.99; }90% { opacity: 0.99; }100% { opacity: 0; }}@keyframes layer-4-fade-in-out {from { opacity: 0; }65% { opacity: 0; }75% { opacity: 0.99; }90% { opacity: 0.99; }100% { opacity: 0; }}/** * Patch the gap that appear between the two adjacent div.circle-clipper while the * spinner is rotating (appears on Chrome 38, Safari 7.1, and IE 11). * * Update: the gap no longer appears on Chrome when .spinner-layer's opacity is 0.99, * but still does on Safari and IE. */.gap-patch {position: absolute;box-sizing: border-box;top: 0;left: 45%;width: 10%;height: 100%;overflow: hidden;border-color: inherit;}.gap-patch .circle {width: 1000%;left: -450%;}.circle-clipper {display: inline-block;position: relative;width: 50%;height: 100%;overflow: hidden;border-color: inherit;}.circle-clipper .circle {width: 200%;}.circle {box-sizing: border-box;height: 100%;border-width: 3px; /* STROKEWIDTH */border-style: solid;border-color: inherit;border-bottom-color: transparent !important;border-radius: 50%;-webkit-animation: none;animation: none;@apply(--layout-fit);}.circle-clipper.left .circle {border-right-color: transparent !important;-webkit-transform: rotate(129deg);transform: rotate(129deg);}.circle-clipper.right .circle {left: -100%;border-left-color: transparent !important;-webkit-transform: rotate(-129deg);transform: rotate(-129deg);}.active .circle-clipper.left .circle {/* duration: ARCTIME */-webkit-animation: left-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;animation: left-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;}.active .circle-clipper.right .circle {/* duration: ARCTIME */-webkit-animation: right-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;animation: right-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;}@-webkit-keyframes left-spin {from { -webkit-transform: rotate(130deg); }50% { -webkit-transform: rotate(-5deg); }to { -webkit-transform: rotate(130deg); }}@keyframes left-spin {from { transform: rotate(130deg); }50% { transform: rotate(-5deg); }to { transform: rotate(130deg); }}@-webkit-keyframes right-spin {from { -webkit-transform: rotate(-130deg); }50% { -webkit-transform: rotate(5deg); }to { -webkit-transform: rotate(-130deg); }}@keyframes right-spin {from { transform: rotate(-130deg); }50% { transform: rotate(5deg); }to { transform: rotate(-130deg); }}#spinnerContainer.cooldown {/* duration: SHRINK_TIME */-webkit-animation: container-rotate 1568ms linear infinite, fade-out 400ms cubic-bezier(0.4, 0.0, 0.2, 1);animation: container-rotate 1568ms linear infinite, fade-out 400ms cubic-bezier(0.4, 0.0, 0.2, 1);}@-webkit-keyframes fade-out {from { opacity: 0.99; }to { opacity: 0; }}@keyframes fade-out {from { opacity: 0.99; }to { opacity: 0; }}</style>

  <template>

    <div id="spinnerContainer" class-name="[[_spinnerContainerClassName]]">
      <div class="spinner-layer layer-1">
        <div class="circle-clipper left">
          <div class="circle"></div>
        </div><div class="gap-patch">
          <div class="circle"></div>
        </div><div class="circle-clipper right">
          <div class="circle"></div>
        </div>
      </div>

      <div class="spinner-layer layer-2">
        <div class="circle-clipper left">
          <div class="circle"></div>
        </div><div class="gap-patch">
          <div class="circle"></div>
        </div><div class="circle-clipper right">
          <div class="circle"></div>
        </div>
      </div>

      <div class="spinner-layer layer-3">
        <div class="circle-clipper left">
          <div class="circle"></div>
        </div><div class="gap-patch">
          <div class="circle"></div>
        </div><div class="circle-clipper right">
          <div class="circle"></div>
        </div>
      </div>

      <div class="spinner-layer layer-4">
        <div class="circle-clipper left">
          <div class="circle"></div>
        </div><div class="gap-patch">
          <div class="circle"></div>
        </div><div class="circle-clipper right">
          <div class="circle"></div>
        </div>
      </div>
    </div>

  </template>

  <script>

    Polymer({

      is: 'paper-spinner',

      listeners: {
        'animationend': 'reset',
        'webkitAnimationEnd': 'reset'
      },

      properties: {

        /**
         * Displays the spinner.
         *
         * @attribute active
         * @type boolean
         * @default false
         */
        active: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          observer: '_activeChanged'
        },

        /**
         * Alternative text content for accessibility support.
         * If alt is present, it will add an aria-label whose content matches alt when active.
         * If alt is not present, it will default to 'loading' as the alt value.
         *
         * @attribute alt
         * @type string
         * @default 'loading'
         */
        alt: {
          type: String,
          value: 'loading',
          observer: '_altChanged'
        },

        /**
         * True when the spinner is going from active to inactive. This is represented by a fade
         * to 0% opacity to the user.
         */
        _coolingDown: {
          type: Boolean,
          value: false
        },

        _spinnerContainerClassName: {
          type: String,
          computed: '_computeSpinnerContainerClassName(active, _coolingDown)'
        }

      },

      _computeSpinnerContainerClassName: function(active, coolingDown) {
        return [
          active || coolingDown ? 'active' : '',
          coolingDown ? 'cooldown' : ''
        ].join(' ');
      },

      _activeChanged: function(active, old) {
        this._setAriaHidden(!active);
        if (!active && old) {
          this._coolingDown = true;
        }
      },

      _altChanged: function(alt) {
        // user-provided `aria-label` takes precedence over prototype default
        if (alt === this.getPropertyInfo('alt').value) {
          this.alt = this.getAttribute('aria-label') || alt;
        } else {
          this._setAriaHidden(alt==='');
          this.setAttribute('aria-label', alt);
        }
      },

      _setAriaHidden: function(hidden) {
        var attr = 'aria-hidden';
        if (hidden) {
          this.setAttribute(attr, 'true');
        } else {
          this.removeAttribute(attr);
        }
      },

      reset: function() {
        this.active = false;
        this._coolingDown = false;
      }

    });

  </script>

</dom-module>
<dom-module id="carbo-inspector-styles" assetpath="/"><template><style>.element-label {font-size: 10px;line-height: 14px;color: white;background-color: green;height: 14px;padding: 2px 4px;float: left;white-space: nowrap;-webkit-transform: translateY(100%);transform: translateY(100%);}#loading div[position="center"] {height: 100%;display: -webkit-flex;display: -ms-flexbox;display: flex;-webkit-flex-direction: row;-ms-flex-direction: row;flex-direction: row;-webkit-align-items: center;-ms-flex-align: center;align-items: center;-webkit-justify-content: center;-ms-flex-pack: center;justify-content: center;}</style></template></dom-module></div><dom-module id="carbo-inspector">
    
    <style include="carbo-inspector-styles"></style>

    <template>

        <template is="dom-repeat" items="{{ _highlighters }}">
            <carbo-highlighter id$="{{ item.id }}" state="{{ item.state }}" target="{{ item.target }}" surface-style="{{ item.surfaceStyle }}">
                <div class="element-label" position="top">{{ item.elementLabel }}</div>
                <div class="element-label" position="bottom" hidden$="{{ !item.owner }}">{{ item.owner }}</div>
            </carbo-highlighter>
        </template>

        <carbo-highlighter id="loading" state="inactive">
            <div position="center">
                <paper-spinner alt="Loading contacts list" active=""></paper-spinner>
            </div>
        </carbo-highlighter>
    </template>
    
    <script src="../lodash/lodash.js"></script>
    <script>// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.nextTick()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
                deferred.reject(new Error(
                    "Can't get fulfillment value from any promise, all " +
                    "promises were rejected."
                ));
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});
</script>

    
    <script>/*******************************************************************************
 CSS0.99.1B :: CSSUtilities 
 -------------------------------------------------------------------------------
 Copyright (c) 2010 James Edwards (brothercake)           <cake@brothercake.com>
 BSD License                           See license.txt for licensing information
 Info/Docs       http://www.brothercake.com/site/resources/scripts/cssutilities/
 -------------------------------------------------------------------------------
 Credits and thanks:
 -------------------------------------------------------------------------------
 Henrik Lindqvist    [Selector.js]              http://llamalab.com/js/selector/
 Dean Edwards        [technical help]                  http://dean.edwards.name/
 Stuart Langridge    [technical help]                  http://www.kryogenix.org/
 -------------------------------------------------------------------------------
*******************************************************************************/

function CSSUtilities() {}
(function()
{
	//-- internal self-reference constant --//
	//this is of course not a constant, it's a variable, but IE doesn't support const 
	//so we use var with the uppercase convention for values that don't change
	//this hook can also be used by the code compression routine, to declare Z=this
	//which can then go on to be replaced for instances of both THIS and this
	var THIS = this;



	//set the asynchronous ready flag to false
	this._allready = false;

	//set the supported flag to false by default 
	this.supported = false;
	
	//do some feature detection
	if(
		
		//this generally excludes pre-DOM1 browsers
		typeof document.getElementById == 'undefined'
		
		//this excludes Opera 8
		|| typeof document.styleSheets == 'undefined'
		
		//this excludes IE 5.5
		|| typeof document.nodeType == 'undefined'
	
	//exit on failure
	){ return; }
		
	//if we're still here, set the supported flag to true
	this.supported = true;
	



	
	//-- start local variable declarations --//
	//-- nb. the breaks in string values are to avoid unwanted compression --//
	
	//we need a flag to signify when initialization is in progress
	//so that we can detect and deal with overlapping asynchronous init calls
	var busyinit = false,



	
	//-- errors and warnings --//

	//-- error constants (for data log messages) --//
	ERROR_NETWORK_OR_SECURITY = 'Network Failure or Security Violation',
	ERROR_NETWORK = 'Network Failure',
	ERROR_SECURITY = 'Security Violation',
	ERROR_UNSPECIFIED = 'Unspecified Error',
	ERROR_NOT_CSS = 'Data is not CSS',
	
	//-- warning message constants (for data log messages) --//
	MESSAGE_UNKNOWN = 'unknown',
	MESSAGE_OK = 'OK',
	MESSAGE_DUPLICATE = 'Discarded Duplicate',
	MESSAGE_DISABLED = 'Stylesheet is disabled',
	MESSAGE_UNSUPPORTED_TYPE = 'Unsupported node type',

	//-- fatal error constants (for console messages) --//
	FATAL_ERROR_PREFIX = 'CSSUtilities ' + '(Fatal Error):',
	FATAL_ERROR_INVALID_MODE = FATAL_ERROR_PREFIX + ' The specified mode is not valid',
	FATAL_ERROR_INVALID_ASYNC = FATAL_ERROR_PREFIX + ' The specified async setting is not valid',
	FATAL_ERROR_NOT_DOCUMENT = FATAL_ERROR_PREFIX + ' The specified document is not a Document',
	FATAL_ERROR_NOT_ABSOLUTE_URI = FATAL_ERROR_PREFIX + ' The specified base is not an absolute URL',
	FATAL_ERROR_INVALID_WATCH = FATAL_ERROR_PREFIX + ' The specified watch setting is not valid',
	FATAL_ERROR_INVALID_ATTRS = FATAL_ERROR_PREFIX + ' The specified attributes setting is not valid',
	FATAL_ERROR_NOT_SAPI = FATAL_ERROR_PREFIX + ' The specified api settings are not valid',
	FATAL_ERROR_INVALID_SAPI = FATAL_ERROR_PREFIX + ' Your Selectors API is not returning the right data',
	FATAL_ERROR_MISSING_SAPI = FATAL_ERROR_PREFIX + ' The Selectors API is missing',
	FATAL_ERROR_NO_XHR = FATAL_ERROR_PREFIX + ' Unable to communicate with the network',
	
	//-- error message variables (for console messages) --//
	errorMessageNoElement = 'CSSUtilities.%method has an invalid Element reference or ID',
	errorMessageNoSelector = 'CSSUtilities.%method requires a valid Selector reference',
	errorMessageMultipleSelector = 'CSSUtilities.%method can only process one Selector at a time',
	errorMessageInvalidSSID = 'CSSUtilities.%method has an invalid Stylesheet ID',
	errorMessageNotAfterAPI = FATAL_ERROR_PREFIX + ' You cannot define "%var" after "api",' + ' it must be defined first',




	//-- css data constants --//
	
	//media defaults and special values
	MEDIA_ALL = 'all',
	MEDIA_SCREEN = 'screen',
	MEDIA_NONE = 'none',
	MEDIA_CURRENT = 'current',
	
	//all valid CSS media types, used as part of the view media detection
	//this list includes all standard media types from CSS2, plus the new "reader" type proposed in CSS3
	MEDIA_TYPES_LIST = 'aural,braille,embossed,handheld,print,projection,reader,screen,speech,tty,tv',
	
	//alphabetical dictionary of inheritable CSS properties
	//we only actually need the keys, so we can go typeof INHERITED_PROPS[key] != 'undefined'
	//but the values are used for dev reference, so that we know the status of each property:
	//	'2'		CSS2 properties
	//	'3'		CSS3 properties 
	//	'?'		CSS3 properties with "inheritable" marked as "yes or ?"
	//	'm'		mozilla extensions
	//	'o'		opera extensions
	//	'w'		webkit extensions
	//	'e'		explorer extensions
	//nb. this list is complete with respect to standard properties, mozilla and opera extensions;
	//but there may be inheritable webkit and explorer extensions not listed here
	//because I couldn't find a definitive list of explorer props 
	//and the apple reference doesn't say whether properties are inheritable
	INHERITED_PROPS = {
		'azimuth':						'2',
		'border-collapse':				'2',
		'border-spacing':				'2',
		'caption-side':					'2',
		'color':						'2',
		'cursor':						'2',
		'direction':					'2',
		'elevation':					'2',
		'empty-cells':					'2',
		'fit':							'3',
		'fit-position':					'3',
		'font':							'2',
		'font-family':					'2',
		'font-size':					'2',
		'font-size-adjust':				'2',
		'font-stretch':					'2',
		'font-style':					'2',
		'font-variant':					'2',
		'font-weight':					'2',
		'hanging-punctuation':			'3',
		'hyphenate-after':				'3',
		'hyphenate-before':				'3',
		'hyphenate-character':			'3',
		'hyphenate-lines':				'3',
		'hyphenate-resource':			'3',
		'hyphens':						'3',
		'image-resolution':				'3',
		'letter-spacing':				'2',
		'line-height':					'2',
		'line-stacking':				'3',
		'line-stacking-ruby':			'3',
		'line-stacking-shift':			'3',
		'line-stacking-strategy':		'3',
		'list-style':					'2',
		'list-style-image':				'2',
		'list-style-position':			'2',
		'list-style-type':				'2',
		'marquee-direction':			'3',
		'orphans':						'2',
		'overflow-style':				'3',
		'page':							'2',
		'page-break-inside':			'2',
		'pitch':						'2',
		'pitch-range':					'2',
		'presentation-level':			'3',
		'punctuation-trim':				'3',
		'quotes':						'2',
		'richness':						'2',
		'ruby-align':					'3',
		'ruby-overhang':				'3',
		'ruby-position':				'3',
		'speak':						'2',
		'speak-header':					'2',
		'speak-numeral':				'2',
		'speak-punctuation':			'2',
		'speech-rate':					'2',
		'stress':						'2',
		'text-align':					'2',
		'text-align-last':				'3',
		'text-emphasis':				'3',
		'text-height':					'3',
		'text-indent':					'2',
		'text-justify':					'3',
		'text-outline':					'3',
		'text-replace':					'?',
		'text-shadow':					'3',
		'text-transform':				'2',
		'text-wrap':					'3',
		'visibility':					'2',
		'voice-balance':				'3',
		'voice-family':					'2',
		'voice-rate':					'3',
		'voice-pitch':					'3',
		'voice-pitch-range':			'3',
		'voice-stress':					'3',
		'voice-volume':					'3',
		'volume':						'2',
		'white-space':					'2',
		'white-space-collapse':			'3',
		'widows':						'2',
		'word-break':					'3',
		'word-spacing':					'2',
		'word-wrap':					'3',
		
		//the mozilla extensions are all proprietary properties
		'-moz-force-broken-image-icon':	'm',
		'-moz-image-region':			'm',
		'-moz-stack-sizing':			'm',
		'-moz-user-input':				'm',
		'-x-system-font':				'm',
		
		//the opera extensions are all draft implementations of CSS3 properties
		'-xv-voice-balance':			'o',
		'-xv-voice-pitch':				'o',
		'-xv-voice-pitch-range':		'o',
		'-xv-voice-rate':				'o',
		'-xv-voice-stress':				'o',
		'-xv-voice-volume':				'o',
		
		//the explorer extensions are all draft implementations of CSS3 properties
		'-ms-text-align-last':			'e',
		'-ms-text-justify':				'e',
		'-ms-word-break':				'e',
		'-ms-word-wrap':				'e'
		},
	
	//lists of longhand CSS properties indexed by their defining shorthand properties
	//nb. the reason this is a group object rather than individual constants
	//is so that we can refer to the longhand property lists by the name of the shorthand property
	LONGHAND_PROPERTIES = {
		//CSS2 shorthand properties 
		'margin': 			['margin-top','margin-right','margin-bottom','margin-left'],
		'padding': 			['padding-top','padding-right','padding-bottom','padding-left'],
		'outline': 			['outline-width','outline-style','outline-color'],
		//(the "border" shorthand defines a set of further shorthands
		// so we have to break those down individually as well)
		'border': 			['border-width','border-style','border-color','border-top','border-right','border-bottom','border-left','border-top-width','border-right-width','border-bottom-width','border-left-width','border-top-style','border-right-style','border-bottom-style','border-left-style','border-top-color','border-right-color','border-bottom-color','border-left-color'],
		'border-width': 	['border-top-width','border-right-width','border-bottom-width','border-left-width'],
		'border-style': 	['border-top-style','border-right-style','border-bottom-style','border-left-style'],
		'border-color': 	['border-top-color','border-right-color','border-bottom-color','border-left-color'],
		'border-top': 		['border-top-width','border-top-style','border-top-color'],
		'border-right': 	['border-right-width','border-right-style','border-right-color'],
		'border-bottom': 	['border-bottom-width','border-bottom-style','border-bottom-color'],
		'border-left': 		['border-left-width','border-left-style','border-left-color'],
		'list-style': 		['list-style-type','list-style-image','list-style-position'],
		'font': 			['font-weight','font-style','font-variant','font-size','line-height','font-family'],
		//(the "background" shorthand defines five properties in CSS2 [the first five]
		// plus three additional properties in CSS3 [the last three])
		'background': 		['background-color','background-image','background-repeat','background-attachment','background-position','background-size','background-clip','background-origin'],
		//CSS3 shorthand properties 
		'line-stacking': 	['line-stacking-strategy','line-stacking-ruby','line-stacking-shift'],
		'column-rule': 		['column-rule-width','column-rule-style','column-rule-color'],
		'columns': 			['column-width','column-count'],
		'pause': 			['pause-before','pause-after'],
		'rest': 			['rest-before','rest-after'],
		'cue': 				['cue-before','cue-after'],
		'mark': 			['mark-before','mark-after'],
		'transition':		['transition-property','transition-duration','transition-timing-function','transition-delay'],
		'animation':		['animation-name','animation-duration','animation-timing-function','animation-delay','animation-iteration-count','animation-direction'],
		//(I hate this module, it has no place in CSS, and the draft spec doesn't even make sense)
		'target': 			['target-name','target-new','target-position']
		},
		


	
	//-- regular expression constants --//
	//-- nb. the use or omission of brackets is significant in each case --//
	//-- for match() returns and backreferences, so don't edit them carelessly! --//
	
	//replace a single pseudo-element, which we have to manually filter from some selectors
	//to avoid them being incorrectly returned by querySelectorAll
	//for simplicity we're allowing single or double-colon syntax for all of them
	//even though the spec only requires support for single-colon syntax 
	//for pseudo-elements that were defined in CSS2 (first-letter, first-line, before and after)
	//this is non-greedy because it's used to check one selector at a time, not multiple 
	//comma-delimited selectors, and a single selector is only allowed to contain one pseudo-element
	REGEX_SINGLE_PSEUDO_ELEMENT = /[:]{1,2}(?:first\-(letter|line)|before|after|selection|value|choices|repeat\-(item|index)|outside|alternate|(line\-)?marker|slot\([_a-z0-9\-\+\.\\]*\))/i,
	
	//match pseudo-elements, used as part of specificity calculation
	//I know this code is almost an exact duplication of the single pseudo-element regex
	//that we could avoid by saving the common code as a string and then using the RegExp constructor
	//but I don't like using RegExp - it behaves differently than regex literals, and leaks memory,
	//and I've done extensive testing with these ones now, it would make me too nervous to change them
	//(because I did change them, and it made me nervous, so I changed them back!)
	//anyway it's only 142 bytes, so it's not gonna break the bank to repeat it once :-P
	REGEX_PSEUDO_ELEMENTS = /([:]{1,2}(?:first\-(letter|line)|before|after|selection|value|choices|repeat\-(item|index)|outside|alternate|(line\-)?marker|slot\([_a-z0-9\-\+\.\\]*\)))/ig,
	
	//match all pseudo-classes except :not(), used as part of specificity calculation:
	//for the purposes of specificity calculation, selectors inside :not() conditions 
	//are counted irrespective of the negation, however :not() itself is not counted as a pseudo-class 
	//this will also let through some fake permutations, like "nth-letter" and "only-of-child",
	//but that doesn't really matter .. it might be fun for someone to fool with, you never know!
	REGEX_PSEUDO_CLASSES_EXCEPT_NOT = /([:](?:(link|visited|active|hover|focus|lang|root|empty|target|enabled|disabled|checked|default|valid|invalid|required|optional)|((in|out\-of)\-range)|(read\-(only|write))|(first|last|only|nth)(\-last)?\-(child|of\-type))(?:\([_a-z0-9\-\+\.\\]*\))?)/ig,
	
	//match attribute selectors (including substring-matching), used as part of specificity calculation
	REGEX_ATTR_SELECTORS = /(\[\s*[_a-z0-9-:\.\|\\]+\s*(?:[~\|\*\^\$]?=\s*[\"\'][^\"\']*[\"\'])?\s*\])/ig,
	
	//match ID selectors, used as part of specificity calculation
	REGEX_ID_SELECTORS = /(#[a-z]+[_a-z0-9-:\\]*)/ig,
	
	//match class selectors, used as part of specificity calculation
	REGEX_CLASS_SELECTORS = /(\.[_a-z]+[_a-z0-9-:\\]*)/ig,

	//an !important rule, for which we have to check an end-substring
	//so we can't get confused by a "content" property with "!important" in its text
	//which is admittedly unlikely, but entirely possible nonetheless
	IMPORTANT_RULE = /\!\s*important\s*$/i,
	


	
	//-- other data constants --//
	
	//the library version string is used as a user-agent header for ajax requests
	//abstracting it here is useful for its own sake, but also in case
	//we ever have additional future needs for this particular data
	LIBRARY_VERSION_STRING = 'CSSUtilities/.99',
	
	//shortcuts for primitive values and data types
	//these may not seem like shortcuts because they're longer than the originals
	//but they give the compressor something to hook onto, 
	//and end up making a huge difference in the long run
	//in any case, I've become quite fond of the abstraction...
	TYPE_UNDEFINED = 'undefined',
	TYPE_OBJECT = 'object',
	TYPE_STRING = 'string',
	TYPE_FUNCTION = 'function',
	TYPE_BOOLEAN = 'boolean',
	BOOLEAN_TRUE = true,
	BOOLEAN_FALSE = false,
	NULL_VALUE = null,
	
	//...and there's a few internals that benefit from it too :-)
	MODE_BROWSER = 'browser',
	MODE_AUTHOR = 'author',
	STATUS_ACTIVE = 'active',
	STATUS_CANCELLED = 'cancelled',
	STATUS_INACTIVE = 'inactive',

	//detect some browsers for a few little tweaks where feature detection isn't appropriate
	//ie. where it's not a case of, if feature a is available, 
	//it's a case of, browser x has bug y which requires specific fix z
	//the webkit condition catches generic webkit UAs such as Google Chrome 
	//and the Adobe AIR runtime; the safari definition is split like this 
	//so that it doesn't get compressed (that single space is crucial!)
	SAFARI = navigator.vendor == 'Apple Computer,' + ' Inc.',
	SAFARI3 = SAFARI && /version\/3/i.test(navigator.appVersion),
	KONQUEROR = navigator.vendor == 'KDE',
	WEBKIT = /applewebkit/i.test(navigator.userAgent),
	IEXPLORER = typeof document.uniqueID != TYPE_UNDEFINED,
	OPERA = typeof window.opera != TYPE_UNDEFINED,
	
	//timer speed for the routine that watches for stylesheets being 
	//enabled and disabled, and then re-initializes automatically
	//and also the routine that waits for the script to have initialized
	//when calling a public method using an asynchronous callback
	//nothing we do with timers needs to be super-fast, 
	//just fast enough not to keep you hanging around when something happens!
	//and since the watch timer might be running all the time
	//we don't want it to demand anything like significant CPU time
	WATCHER_SPEED_TIMER = 200,
	
	




	//-- privileged environment variables --//
	
	//what kind of rules data to collect, either "browser" centric or "author" defined
	//if you choose browser-centric then the data comes from the document.styleSheets collection, 
	//which means that what we get is subject to each browser's implementation: it only includes 
	//stuff that the browser understands, and properties will be normalized in different ways
	//for example, firefox normalizes colors to rgb, splits out background properties,
	//adds a whole bunch of default -moz properties; opera normalizes colors to hex, 
	//also splits out background properties; safari adds a bunch of -webkit properties
	//IE doesn't do much (apart from extensive capitalization, but we change that back)
	//but it does do a few bits, like splitting out margin properties
	//if you choose browser-agnostic then the data is loaded and parsed as plain text:
	//all values are returned exactly as you defined them in the stylesheet
	//with no normalization, the same spacing [except line breaks and tabs] and quote marks you used, etc.
	//and all browsers return an identical collection of rules and properties
	//irrespective of whether they actually implement those rules and properties
	//this of course means that queries may return data which doesn't actually apply to that browser
	//NOTE: in IE "author" mode, any CSS inside <style> elements has to be retrieved by making 
	//		a synchronous request for the host page itself, as the only way to get raw text 
	//		to work with rather than pre-normalized CSS; therefore the content of <style> blocks 
	//		WILL NOT be included IF those <style> blocks were JS generated, OR the host-page request fails
	//		the same thing is true for the data in style attributes in author mode, unless "attributes" is false
	//to change mode mid session, change this value through define() then call init() to re-initialize
	//the default is browser because I think that's what people will intuitively expect
	//and because author makes a bunch of http request, which may
	//slow down the overall loading speed of the page (although hopefully not too much,
	//given that all the data it's requesting will generally already be in the browser's cache,
	//except of course where this is being run on a page they're viewing for the first time anyway!)
	mode = MODE_BROWSER,
	
	//whether to get data asynchronously
	async = BOOLEAN_FALSE,

	//context document
	page = document,
	
	//base for qualifying stylesheet hrefs, can't be defined until init
	//because it refers to page, which may change between now and then
	base,
	
	//whether to watch for changes in the disabled state of stylesheets
	//and re-initialize automatically in response
	//we set this to false by default because it uses setInterval
	//and we don't want that running unecessarily, when users may not
	//even think about it and just leave it at the default setting
	watch = BOOLEAN_FALSE,
	
	//whether to include data from style attributes
	attributes = BOOLEAN_TRUE,
	
	//selectors API backup when native implementation is not available
	//we bundle Selector.js by default, or others can be used via function argument
	//null means we don't yet know whether native implementation is available
	//if it is this will be set to false, unless it's already been set to true
	//if set to true then all browsers will use the backup function
	//qsa is a reference to a wrapper for the custom backup function, if specified
	api = NULL_VALUE, qsa = NULL_VALUE, apidefined = BOOLEAN_FALSE;
		
		
		
		
	//-- public method for modifying privileged variables --//
	this.define = function(varname, value1, value2)
	{
		//validate definitions before saving their values
		//for definable values that are invalid, throw a fatal error
		//for non-definable values just silently fail
		switch(varname)
		{
			//"mode" 
			case 'mode' :
			
				//must be "author" or "browser"
				if(typeof value1 != TYPE_STRING || !/^(author|browser)$/i.test(value1))
				{
					throw(new Error(FATAL_ERROR_INVALID_MODE));
				}
				
				//save the value
				mode = value1;
				
				//if mode is now "browser" check that "watch" is not null
				if(mode == MODE_BROWSER && watch === NULL_VALUE)
				{
					throw(new Error(FATAL_ERROR_INVALID_WATCH));
				}
				
				break;
			
			//"async"
			case 'async' :
			
				//must be a boolean
				if(typeof value1 != TYPE_BOOLEAN) 
				{ 
					throw(new Error(FATAL_ERROR_INVALID_ASYNC));
				}
				
				//save the value
				async = value1;
				
				break;
			
			//"page" 
			case 'page' :
			
				//if "api" already has a user-definition, 
				//throw the error that says this must be defined first
				if(apidefined == BOOLEAN_TRUE)
				{
					throw(new Error(errorMessageNotAfterAPI.replace('%var', 'page'))); 
				}
			
				//must be a #document node
				if(typeof value1.nodeType == TYPE_UNDEFINED || value1.nodeType != 9)
				{
					throw(new Error(FATAL_ERROR_NOT_DOCUMENT));
				}
				
				//save the value
				page = value1;
				
				break;
			
			//"base" 
			case 'base' : 
			
				//if "api" already has a user-definition, 
				//throw the error that says this must be defined first
				if(apidefined == BOOLEAN_TRUE)
				{
					throw(new Error(errorMessageNotAfterAPI.replace('%var', 'base'))); 
				}
			
				//must be an absolute URI string
				if(typeof value1 != TYPE_STRING || !/^(((ht|f)tp[s]?)\:)/i.test(value1))
				{
					throw(new Error(FATAL_ERROR_NOT_ABSOLUTE_URI));
				}
				
				//save the value
				base = value1;
				
				break;
				
			//"attributes"
			case 'attributes' :
			
				//must be a boolean
				if(typeof value1 != TYPE_BOOLEAN) 
				{ 
					throw(new Error(FATAL_ERROR_INVALID_ATTRS));
				}
				
				//save the value
				attributes = value1;
				
				break;
			
			//"watch" 
			case 'watch' :
			
				//must be true or false in browser mode
				//must be true, false or null in author mode
				if(!(typeof value1 == TYPE_BOOLEAN || (mode == MODE_AUTHOR && value1 == NULL_VALUE)))
				{ 
					throw(new Error(FATAL_ERROR_INVALID_WATCH));
				}
				
				//save the value
				watch = value1;
				
				break;
				
			//"api" 
			case 'api' :
			
				//must be a boolean
				if(typeof value1 != TYPE_BOOLEAN)
				{ 
					throw(new Error(FATAL_ERROR_NOT_SAPI));
				}
				
				//and its function if specified must be a function
				if(typeof value2 != TYPE_UNDEFINED)
				{
					if(typeof value2 != TYPE_FUNCTION)
					{
						throw(new Error(FATAL_ERROR_NOT_SAPI));
					}
				}
	
				//the api property is false if we have native support, or null if we don't
				//so if this gets set to [or left as] false that means use native where supported
				//or if it gets set to true that means use the backup function for everyone
				if(value1 == BOOLEAN_FALSE)
				{
					api = typeof page.querySelectorAll == TYPE_UNDEFINED;
				}
				else 
				{
					api = BOOLEAN_TRUE;
				}
				
				//indicate that this variable has been used-defined
				//so that we can prevent the later definition of "page" or "base"
				//both of which need to have been defined first 
				//so that the custom api method can be tested in the correct context
				apidefined = BOOLEAN_TRUE;
				
				//if we have a function definition, pre-test it to make sure 
				//that it returns the correct data structure (an array or nodelist)
				//and if not throw a fatal error
				if(typeof value2 == TYPE_FUNCTION) 
				{ 
					var nodes = value2('*', page); 
					if(typeof nodes != TYPE_OBJECT || nodes == NULL_VALUE || typeof nodes.length == TYPE_UNDEFINED)
					{
						throw(new Error(FATAL_ERROR_INVALID_SAPI));
					}
	
					//save the value if we're good
					qsa = value2; 
				}

				break;
				
		}
	};
	
	
	
	
	//-- public methods --//
	
	//initialize the library to re/build/refresh the internal data cache
	this.init = function(callback)
	{
		//if initialization is already in progress, ignore this call
		//we need to do this to prevent overlapping asynchronous calls
		if(busyinit === BOOLEAN_TRUE) 
		{ 
			return; 
		}
		
		//set the busy flag to signify that initialization is in progess
		busyinit = BOOLEAN_TRUE;
		
		//clear the global ready flag 
		this._allready = BOOLEAN_FALSE;
		
		//if querySelectorAll is supported, and api has not been set to true, set it to false
		//false means we can use the native method if supported; true means use the backup for all
		api = (typeof page.querySelectorAll != TYPE_UNDEFINED && api !== BOOLEAN_TRUE) 
				? BOOLEAN_FALSE 
				: BOOLEAN_TRUE;
		
		//if base hasn't been defined, do so now
		if(base == NULL_VALUE) { base = page.location.href; }

		//detect XML (including HTML in XHTML mode)
		//opera doens't support document.xmlVersion so it has a different test
		this._isXML = (OPERA && page.documentElement.namespaceURI != NULL_VALUE)
						|| (!OPERA && (typeof page.xmlVersion != TYPE_UNDEFINED && page.xmlVersion != NULL_VALUE));
		
		//get the current page view media
		this._viewmedia = getViewMedia(); 
		
		//nullify and delete the rules data and debug stylesheets array
		//this is only pertinent when re-initialising mid-session
		//but it must be done to avoid retaining properties that are gone since last time
		this._cssRules = NULL_VALUE;
		delete this._cssRules;
		this._stylesheets = NULL_VALUE;
		delete this._stylesheets;

		//define the local callback
		function localcallback()
		{
			//clear the busy init flag
			busyinit = BOOLEAN_FALSE;
			
			//set the global ready flag
			CSSUtilities._allready = BOOLEAN_TRUE;
			
			//if callback is a function, save the reference and call it
			if(typeof callback == TYPE_FUNCTION) 
			{
				CSSUtilities.initcallback = callback;
				CSSUtilities.initcallback();
			}

			//otherwise nullify and delete any existing reference
			else
			{
				CSSUtilities.initcallback = NULL_VALUE;
				delete CSSUtilities.initcallback;
			}
		
			//***DEV
			//function dbSize(obj){function stringify(obj){var str = '';for(var i in obj){if(!obj.hasOwnProperty(i)) { continue; }if(typeof obj[i] == TYPE_STRING){str += obj[i];}else{str += stringify(obj[i]);}}return str;}return stringify(obj).length;}
			//document.title = (typeof time != TYPE_UNDEFINED ? '(' + time + 'ms) | ' : '') + 'mode=' + mode + ' | async=' + async + ' | dbsize=' + (Math.round(dbSize(THIS._cssRules) / 10) / 100) + 'KiB | ' + new Date().toUTCString();
		}
		
		//create the new cssRules and stylesheets arrays
		THIS._cssRules = [];
		THIS._stylesheets = [];
		
		//start a new ssidcounter for assigning stylesheet IDs
		THIS.ssidcounter = 0;

		//[re]create the core rules data array according to mode
		//passing in the local callback reference for its completion
		//all the other methods will work off this data so that
		//we don't have to query the stylesheets collection more than once per session
		//(unless it's dynamically changed, after which we have to re-init())
		if(mode == MODE_AUTHOR) 
		{ 
			createAuthorRulesData(localcallback); 
		}
		else 
		{ 
			createBrowserRulesData(localcallback); 
		}
	};
		
	//***DEV data object dump
	//this.dumpDataObject = function(){
	//	var str='\n\n\n'
	//		+ '--[ raw da'+'ta dump ]------------------------------------------------------------------------------\n\n'
	//		+ '';
	//	for(var i=0; i<THIS._cssRules.length; i++){str+=i+':\n';for(var j in THIS._cssRules[i]){str += '\t"' + j + '": ';if(typeof THIS._cssRules[i][j] == TYPE_STRING) { str += '"'; }str += THIS._cssRules[i][j];if(typeof THIS._cssRules[i][j] == TYPE_STRING) { str += '"'; }str += '\n';}}return str;
	//};

	//public getCSSStyleSheets returns all the stylesheets
	//that the class was able to retrieve data from
	this.getCSSStyleSheets = function()
	{
		//process the arguments to create an indexed object
		var args = processArguments(arguments, []);
		
		//process the onfinished argument, 
		//which sets it to null if undefined or not a function, for ease of reference
		args.onfinished = processOnfinishedArgument(args.onfinished);
		
		//if the script hasn't been initialized, do so now
		lateinit();
		
		//create an internal wrapper for the rest of this function
		//so that we can call it differently for callback or return
		//then wrap the whole thing in a returned call to the
		//dispatchReturn method, which abstracts that process,
		return dispatchReturn(args.onfinished, function()
		{
			//return the debug stylesheets array
			return THIS._stylesheets;

		});
	};	
	
	//public getCSSRules return all the style rules 
	//that apply to an element within a specified media
	this.getCSSRules = function()
	{
		//process the arguments to create an indexed object
		var args = processArguments(arguments, ['element','media','accept','altstates']);
		
		//process the element argument
		//this creates an element reference from an ID
		//and/or throws an error if the element us undefined, null, or not an element
		args.element = processElementArgument(args.element, 'getCSSRules');
		
		//process the media argument
		//this sets default if undefined, empty or null
		//then splits it into a trimmmed array
		args.media = processMediaArgument(args.media);
		
		//process the accept argument
		//this parameter allows us to limit how much data is retrieved
		//for the sake of efficiency, so that we only have to keep in memory 
		//- and more to the point, only have to process - 
		//the properties that are needed by the calling operation
		//the options are the same as the complete set returned by this.getCSSRules:
		//"selector", "css", "media", "owner", "href", "ssid",
		//	"properties", "specificity", "index", "inheritance", "altstate"; 
		//		or "*" to return all values
		//which is the default value if the accept argument is undefined, empty, null or "null"
		//once processed it will either be the string value "*" 
		//or an object of properties, eg. selector and css
		//this is so we can easily go typeof accept[key] against a property name
		//rather than having to test for substrings each time
		args.accept = processAcceptArgument(args.accept);
		
		//if altstates is null, make it false
		//the altstates parameter specifies whether to include selectors as being applicable
		//that apply to interactive states of the element which it isn't necessarily in at the moment
		//and which are all defined in pseudo-classes such as :visited and :hover
		if(args.altstates == NULL_VALUE) { args.altstates = BOOLEAN_FALSE; }
		
		//process the onfinished argument, 
		//which sets it to null if undefined or not a function, for ease of reference
		args.onfinished = processOnfinishedArgument(args.onfinished);
		
		//if the script hasn't been initialized, do so now
		lateinit();
		
		//create an internal wrapper for the rest of this function
		//so that we can call it differently for callback or return
		//then wrap the whole thing in a returned call to the
		//dispatchReturn method, which abstracts that process,
		return dispatchReturn(args.onfinished, function()
		{
			//get and return the rule objects for the specified media
			//passing on the accept and altstates arguments directly for processing in getCSSRules
			return getCSSRules(args.element, args.media, args.accept, args.altstates);
		
		});
	};

	//public getCSSStyleSheetRules return all the style rules 
	//that we have in the dataset, within a specified media
	//the final argument is the oncomplte callback, which is called onfinished
	//just for internal grouping of callbacks (all public methods have onfinished)
	this.getCSSStyleSheetRules = function()
	{
		//process the arguments to create an indexed object
		var args = processArguments(arguments, ['media','accept','ssid']);
		
		//process the media argument
		//this sets default if undefined, empty or null
		//then splits it into a trimmmed array
		args.media = processMediaArgument(args.media);
		
		//process the accept argument
		args.accept = processAcceptArgument(args.accept);
		
		//if accept contains "properties" but not "css"
		//we need css to get properties, so add it to the accept object
		//but then set a flag so that we know to delete it again at the end
		if(typeof args.accept.properties != TYPE_UNDEFINED && typeof args.accept.css == TYPE_UNDEFINED)
		{
			args.accept.css = '';
			var deletecss = BOOLEAN_TRUE;
		}
		
		//if the ssid argument is null, default to -1 
		//we need to check these strictly to avoid automatic type detection
		//that could could confuse false with zero
		if(args.ssid === NULL_VALUE) { args.ssid = -1; }
		
		//process the onfinished argument, 
		//which sets it to null if undefined or not a function, for ease of reference
		args.onfinished = processOnfinishedArgument(args.onfinished);
		
		//if the script hasn't been initialized, do so now
		lateinit();

		//if ssid is specified but invalid (ie. there's no stylesheet with that ssid), throw an error
		if(args.ssid !== -1 && arrayContains(this._stylesheets, args.ssid, 'ssid') == NULL_VALUE)
		{
			throw(new Error(errorMessageInvalidSSID.replace('%method', 'getCSSStyleSheetRules'))); 
		}
		
		//create an internal wrapper for the rest of this function
		//so that we can call it differently for callback or return
		//then wrap the whole thing in a returned call to the
		//dispatchReturn method, which abstracts that process,
		return dispatchReturn(args.onfinished, function()
		{
			//create a rules array
			var rules = [];
			
			//now iterate through the main rules array to build the data
			for(var i=0; i<THIS._cssRules.length; i++)
			{
				//create the object for this rule
				var cssrule = {};
				
				//if the media of this rule matches the input criteria
				if(mediaMatches(args.media, THIS._cssRules[i]))
				{
					//if the ssid argument is not -1
					//then don't include this rule if its ssid doesn't match
					//again, we use strict tests to avoid any ambiguity
					//caused by automatic type conversion
					if(args.ssid !== -1 && THIS._cssRules[i].ssid !== args.ssid) { continue; }
					
					//for each property in this member, if it's defined in accept, 
					//or accept is "*", add it to the rule object
					for(var j in THIS._cssRules[i])
					{
						if(!THIS._cssRules[i].hasOwnProperty(j)) { continue; }
						
						if(args.accept == '*' || typeof args.accept[j] != TYPE_UNDEFINED)
						{
							cssrule[j] = THIS._cssRules[i][j];
						}
					}
					
					//add the index property, if defined in accept or accept is "*"
					if(args.accept == '*' || typeof args.accept.index != TYPE_UNDEFINED)
					{
						cssrule.index = i;
					}
					
					//add this rule to the array
					rules.push(cssrule);
				}
			}
			
			//if accept is an object containing "properties", or its the string "*"
			//pass the rules array to the addSortedProperties object
			//but with a false dosort argument so that it returns all the properties equally
			//rather than identifying and marking all the cancelled and inactive ones
			if(typeof args.accept.properties != TYPE_UNDEFINED || args.accept === '*')
			{
				rules = addSortedProperties(rules, BOOLEAN_FALSE);
			}
			
			//if the deletecss flag is defined, we need to 
			//nullify and delete all the css properties
			if(typeof deletecss != TYPE_UNDEFINED)
			{
				for(var i=0; i<rules.length; i++)
				{
					rules[i].css = NULL_VALUE;
					delete rules[i].css;
				}
			}
			
			//return the final rules array
			return rules;
		
		});
	};
	
	//public getCSSProperties method returns all the style properties 
	//that are  actually defined for this element in stylesheets
	//(rather than computed values or style properties)
	this.getCSSProperties = function()
	{
		//process the arguments to create an indexed object
		var args = processArguments(arguments, ['element','media']);
		
		//process the element argument
		//this creates an element reference from an ID
		//and/or throws an error if the element us undefined, null, or not an element
		args.element = processElementArgument(args.element, 'getCSSProperties');
		
		//process the media argument
		//this sets default if undefined, empty or null
		//then splits it into a trimmmed array
		args.media = processMediaArgument(args.media);
		
		//process the onfinished argument, 
		//which sets it to null if undefined or not a function, for ease of reference
		args.onfinished = processOnfinishedArgument(args.onfinished);
		
		//if the script hasn't been initialized, do so now
		lateinit();
		
		//create an internal wrapper for the rest of this function
		//so that we can call it differently for callback or return
		//then wrap the whole thing in a returned call to the
		//dispatchReturn method, which abstracts that process,
		return dispatchReturn(args.onfinished, function()
		{
			//create the properties object
			var properties = {};
			
			//get all the rules that apply to this element and media
			//but we only need the "properties" from each rule
			//and for altstates to be false so we only get the properties that actually apply now
			var rules = getCSSRules(args.element, args.media, 'properties', BOOLEAN_FALSE);
			
			//if there are no rules returned, return null for failure
			if(rules.length == 0) { return NULL_VALUE; }
			
			//iterate through the returned collection, then the 
			//properties object in each member, and add each property value 
			//in turn to the final properties object, if its status is "active"
			for(var i=0; i<rules.length; i++)
			{
				for(var j in rules[i].properties)
				{
					if(!rules[i].properties.hasOwnProperty(j)
						|| rules[i].properties[j].status != STATUS_ACTIVE) { continue; }
					
					properties[j] = rules[i].properties[j].value;
				}
			}

			
			//return the final properties object
			return properties;
		
		});
	};
	
	//public getCSSSelectors returns all the selectors that apply to an element
	//the second argument specifies whether to return only direct selectors (true)
	//or selectors which apply indirectly through inheritance (false)
	this.getCSSSelectors = function()
	{
		//process the arguments to create an indexed object
		var args = processArguments(arguments, ['element','media','directonly']);
		
		//process the element argument
		//this creates an element reference from an ID
		//and/or throws an error if the element us undefined, null, or not an element
		args.element = processElementArgument(args.element, 'getCSSSelectors');
		
		//process the media argument
		//this sets default if undefined, empty or null
		//then splits it into a trimmmed array
		args.media = processMediaArgument(args.media);
		
		//if the directonly flag is null, default to true
		if(args.directonly == NULL_VALUE) { args.directonly = BOOLEAN_TRUE; }
		
		//process the onfinished argument, 
		//which sets it to null if undefined or not a function, for ease of reference
		args.onfinished = processOnfinishedArgument(args.onfinished);
		
		//if the script hasn't been initialized, do so now
		lateinit();
		
		//create an internal wrapper for the rest of this function
		//so that we can call it differently for callback or return
		//then wrap the whole thing in a returned call to the
		//dispatchReturn method, which abstracts that process,
		return dispatchReturn(args.onfinished, function()
		{
			//create an array of all selectors
			var allselectors = [];
	
			//now get all the rules that apply to this element and media
			//we only need the "selector" property from each rule
			//pass true as the altstates argument so that we get selectors
			//for every state, not just those that apply by default
			var rules = getCSSRules(args.element, args.media, 'selector', BOOLEAN_TRUE);
			
			//then iterate through the rules collection and send the selector text from each one
			//to the parseSelectorText method, which will split the selector into individual selectors
			//and then add each one to the allselectors array, if it hasn't already been listed
			for(var i=0; i<rules.length; i++)
			{
				var selectors = parseSelectorText(rules[i].selector);
				for(var j=0; j<selectors.length; j++)
				{
					if(arrayContains(allselectors, selectors[j]) == NULL_VALUE)
					{
						allselectors.push(selectors[j]);
					}
				}
			}
			
			//if we want inherited as well as direct selectors
			if(args.directonly == BOOLEAN_FALSE) 
			{	
				//we have to iterate through it and remove any selectors
				//which don't apply to the element or to any of its ancestors
				//nb. we remove any state-dependent pseudo-classes from the test selector each time
				//so that we include rules that apply to non-default states like :hover
				var node = args.element, 
					ancestors = [node];
				while(node.parentNode) 
				{ 
					ancestors.push(node.parentNode); 
					node = node.parentNode; 
				}
				for(var i=0; i<allselectors.length; i++)
				{
					var applies = BOOLEAN_FALSE;
					for(var j=0; j<ancestors.length; j++)
					{
						var nodes = getElementsBySelector(allselectors[i].replace(REGEX_PSEUDO_CLASSES_EXCEPT_NOT, ''));
						if(nodes.length > 0)
						{
							for(var k=0; k<nodes.length; k++)
							{
								if(nodes[k] == ancestors[j])
								{
									applies = BOOLEAN_TRUE;
									break;
								}
							}
						}
						if(applies == BOOLEAN_TRUE) { break; }
					}
					//if it doens't apply remove it from the array
					if(applies == BOOLEAN_FALSE)
					{
						allselectors.splice(i, 1);
						i --;
					}
				}
			
				//then return the allselectors array and we're done
				return allselectors;
			}
			
			//if we only want direct selectors, 
			//proceed to create the final output selectors array
			var selectors = [];
			
			//iterate through the allselectors array
			//and evaluate each one against the original element
			//and if it matches, add it to the final selectors array
			//nb. we remove any state-dependent pseudo-classes from the test selector each time
			//so that we include rules that apply to non-default states like :hover
			for(var i=0; i<allselectors.length; i++)
			{
				var nodes = getElementsBySelector(allselectors[i].replace(REGEX_PSEUDO_CLASSES_EXCEPT_NOT, ''));
				if(nodes.length > 0)
				{
					for(var j=0; j<nodes.length; j++)
					{
						if(nodes[j] == args.element)
						{
							selectors.push(allselectors[i]);
							break;
						}
					}
				}
			}
			
			//return the selectors array
			return selectors;
		
		});
	};

	//public getCSSSelectorSpecificity returns the specificity of a selector 
	//either as it applies to an element, or in abstraction
	this.getCSSSelectorSpecificity = function()
	{
		//process the arguments to create an indexed object
		var args = processArguments(arguments, ['selector','element']);
		
		//if selector is undefined, null, empty, or not a string, throw the no selector error
		if(typeof args.selector != TYPE_STRING 
			|| args.selector == NULL_VALUE || trim(args.selector) == '') 
		{ 
			throw(new Error(errorMessageNoSelector.replace('%method', 'getCSSSelectorSpecificity'))); 
		}
		
		//if selector is a string containing any commas, throw the multiple selector error
		else if(args.selector.indexOf(',') != -1)
		{
			throw(new Error(errorMessageMultipleSelector.replace('%method', 'getCSSSelectorSpecificity'))); 
		}
		
		//if the element is null, leave it like that
		//if the element is not null, process the element argument
		//this creates an element reference from an ID
		//and throws an error if the reference is not there, or not an element
		//but the condition allows it to be null if it was originally undefined or null
		if(args.element != NULL_VALUE) 
		{ 
			args.element = processElementArgument(args.element, 'getCSSSelectorSpecificity'); 
		}
		
		//process the onfinished argument, 
		//which sets it to null if undefined or not a function, for ease of reference
		args.onfinished = processOnfinishedArgument(args.onfinished);
		
		//if the script hasn't been initialized, do so now
		lateinit();
		
		//create an internal wrapper for the rest of this function
		//so that we can call it differently for callback or return
		//then wrap the whole thing in a returned call to the
		//dispatchReturn method, which abstracts that process,
		return dispatchReturn(args.onfinished, function()
		{
			//trim the selector
			args.selector = trim(args.selector);
			
			//if the element argument is in use, work out whether this selector applies to it
			//we remove pseudo-classes while checking this so that we get those that apply
			//even if only to a different pseudo-state; but because they're not permanently removed
			//we'll still end up with a specificity value that includes any pseudo-class the selector has
			if(args.element != NULL_VALUE)
			{
				var applies = BOOLEAN_FALSE, 
					nodes = getElementsBySelector(args.selector.replace(REGEX_PSEUDO_CLASSES_EXCEPT_NOT, ''));
				if(nodes.length > 0)
				{
					for(var j=0; j<nodes.length; j++)
					{
						if(nodes[j] == args.element)
						{
							applies = BOOLEAN_TRUE;
							break;
						}
					}
				}
				
				//if the selector doesn't apply 
				if(applies == BOOLEAN_FALSE)
				{
					//see if the selector applies to any of the elements ancestors
					//and if it does then return zero specificity
					var node = args.element, ancestors = [node];
					while(node.parentNode) 
					{ 
						ancestors.push(node); 
						node = node.parentNode; 
					}
					for(var i=0; i<ancestors.length; i++)
					{
						if(nodes.length > 0)
						{
							for(var j=0; j<nodes.length; j++)
							{
								if(nodes[j] == ancestors[i])
								{
									applies = BOOLEAN_TRUE;
									break;
								}
							}
						}
						if(applies == BOOLEAN_TRUE) { break; }
					}
					
					if(applies == BOOLEAN_TRUE)
					{
						return [0,0,0,0];
					}
					
					//if it doesn't even apply to an ancestor, return null
					else { return NULL_VALUE; }
				}
			}
			
			//if the element argument is not in use, or the selector does apply to it, 
			//get and return the specificity of this selector
			return getSelectorSpecificity(args.selector);
		
		});
	};


	//-- shared private method that finalizes the public css methods --//
	
	//dispatch return method deals with the onfinished argument of each public method
	//by calling the applicable inner wrapper and then returning or calling the callback
	function dispatchReturn(onfinished, wrapper)
	{
		//if the ready flag is not true and a callback is not defined
		//return undefined to signal that init is incomplete
		//putting this after the lateinit call ensures that it will
		//only affect asynchronous uses without the internal callback, when the data is not ready
		//it can then be caught by users by testing this method's return value against undefined
		if(THIS._allready !== BOOLEAN_TRUE && onfinished == NULL_VALUE) 
		{ 
			return; 
		}
		
		//or if the ready flag is true and no callback is set 
		//just call and return the internal wrapper
		if(onfinished == NULL_VALUE) 
		{ 
			return wrapper(); 
		}
		
		//otherwise create a timer to wait for the ready property
		//then call the internal wrapper and send its return through the callback
		else
		{
			//if init has happened before then the data will already be ready
			//so if that's the case just do the calback straight away
			if(THIS._allready === BOOLEAN_TRUE)
			{
				onfinished(wrapper());
			}
			
			//otherwise start the timer to wait for it
			//this runs at the same speed as the watch timer though it could 
			//actually afford to be slower, it's fine at this speed too, 
			//and means we can save on having to have a separate value
			//it also never times out; I suppose it could, but it doesn't really 
			//matter if it does end up running forever - it's hardly a major overhead!
			else
			{
				var readywaiter = window.setInterval(function()
				{
					if(THIS._allready === BOOLEAN_TRUE)
					{
						window.clearInterval(readywaiter);
						
						onfinished(wrapper());
					}
				}, WATCHER_SPEED_TIMER);
			}
		}
	}




	//-- private methods for building the author-mode rules data array --//
	
	//create the data array of css style rules from all document stylesheets
	//this all has to be structured in such a way that it works
	//with either synchronous or asynchronous network data retrieval
	function createAuthorRulesData(oncomplete)
	{
		//what we're going to do is load each stylesheet and parse it as text
		//so that we don't have to deal with each browser's normalizing behavior
		//we get a rules collection that is exactly as author defined
		//and the same in every browser, irrespective of its own support
		//so to begin with, we need an array of stylesheet URIs
		//which we can then load and get the text from
		//or for style blocks we can just grab the text straight away
		THIS._cssdata = [];
		
		//if this is IE and the page contains any style element
		//get the raw text inside the page's <style> nodes
		//passing the continuation method as its callback
		//this works by making a request for the host page and 
		//then parsing the HTML to get the contents of <style> elements
		//we only need to do this in "author" mode, 
		//in IE, if the page contains any <style> elements 
		//because their innerHTML/nodeData returns normalized style information
		//instead of just the plain text inside the style node, as with other browsers
		if(IEXPLORER && getTheseElements('style').length > 0)
		{
			getRawStyleData(continuation);
		}
		
		//otherwise just call the continuation method directly
		else { continuation(); }
		
		//continuation method after getting the raw style data
		function continuation()
		{
			//get the collection of all nodes that refer to stylesheets
			var stylenodes = getStyleSheetNodes();
	
			//now iterate through the collection of style nodes 
			//and process each one to get the initial data we need
			for(var i=0; i<stylenodes.length; i++)
			{
				processStyleNode(
					stylenodes[i], 
					stylenodes[i].nodeType == 7 
						? stylenodes[i].target.toLowerCase()
						: stylenodes[i].nodeName.toLowerCase()
					);
			}
			
			//the next few methods are called in order, each progressively
			//by the callback from the previous one, so they can work asynchronously
	
			//1. wrapper for recurring instances of the stage2 check and request method
			function stage1_checkStyleSheetForDataWrapper(cdcount)
			{
				//pass this cssdata to the stage2 check and request method
				stage2_checkStyleSheetForData(THIS._cssdata[cdcount], 
				
				//and when that completes
				function(cssdata)
				{
					//save back the modified object
					THIS._cssdata[cdcount] = cssdata;
					
					//if we have more to process, recur
					if(cdcount + 1 < THIS._cssdata.length) 
					{ 
						stage1_checkStyleSheetForDataWrapper(cdcount + 1); 
					}
					
					//otherwise kick off the stage 3 check for imports process
					else 
					{ 
						stage3_checkStyleSheetForImportsWrapper();
					}
				});
			}
			
			//2. check to see if we have the css text for a stylesheet
			//and make a request for it if we don't
			function stage2_checkStyleSheetForData(cssdata, oncomplete)
			{
				//if the href is null then this is a style block
				//in which case we already have the text, 
				//so just pass the unmodified cssdata back through the oncomplete callback
				if(cssdata.href == NULL_VALUE) { oncomplete(cssdata); }
				
				//otherwise request the stylesheet, which sends back a data object
				//containing the text of a successful request, or an error message
				else
				{
					requestStyleSheet(cssdata.href, function(dataobject)
					{
						//if we have an error message, record it to the cssdata object
						//and nullify the stylenode reference
						//then if the error is an http error or "not css", set the media to "none"
						if(dataobject.message != NULL_VALUE)
						{
							cssdata.message = dataobject.message;
							cssdata.stylenode = NULL_VALUE;
							
							if(cssdata.message == ERROR_NOT_CSS || /^[1-9]{1,3}/.test(cssdata.message))
							{
								cssdata.media = MEDIA_NONE;
							}
						}
						
						//otherwise strain and save the text, leaving valid imports in place for now
						//because we'll need to extract them later to load them in turn
						else 
						{ 
							cssdata.text = strainStyleSheet(dataobject.text, BOOLEAN_FALSE); 
						}
			
						//call oncomplete with the modified cssdata object
						oncomplete(cssdata);
					});
				}
			}
			
			//3. wrapper for calling recurring instances of the stage5 check and request import method
			function stage3_checkStyleSheetForImportsWrapper()
			{
				//4. check a stylesheet for imports
				function stage4_checkStyleSheetForImports(cdindex)
				{
					//local callback for this method
					function localcallback(increment)
					{
						//if there are any more stylesheets to check, recur on the next one
						//increasing the iterator as specified in case we need to re-check
						//the index that we just checked, because it's now a nested import
						//which is added before its parent in the array
						//and that's why we have a .tested flag, to avoid testing the same 
						//stylesheet more than once if we encounter it more than once
						if(cdindex + 1 < THIS._cssdata.length)
						{
							stage4_checkStyleSheetForImports(cdindex + increment);
						}
						
						//otherwise go on to the final stage7 data processor
						else
						{
							stage7_processStyleSheetsData();
						}
					}
					
					//if we've already tested this stylesheet 
					//just call the local callback with a standard increment
					if(THIS._cssdata[cdindex].tested == BOOLEAN_TRUE)
					{
						localcallback(1);
					}
					
					//else proceed
					else
					{
						//look for imports in this stylesheet text
						var importsheets = extractImportStatements(THIS._cssdata[cdindex].text);
						
						//mark that we've tested this stylesheet
						THIS._cssdata[cdindex].tested = BOOLEAN_TRUE;
						
						//assign its ssid; we waited until now to do this
						//so that we can assign them in order of occurence
						THIS._cssdata[cdindex].ssid = THIS.ssidcounter++;
						
						//if we have any imports
						if(importsheets.length > 0)
						{
							//5. wrapper for passing each import 
							//to the stage6 check and request import method
							function stage5_checkImportForDataWrapper(impindex)
							{
								//pass this import data to the stage6 check and request import method
								stage6_checkImportForData(
									cdindex,
									impindex,
									importsheets[impindex],
									
								//and when that completes
								function(cssdata, cdnumber, impnumber)
								{
									//add the object to the master array before its parent
									//which means that imports go before their parent, 
									//and sibling imports maintain their relative order; 
									//this is the correct source order for specificity
									//and can make a huge difference when it comes to rule sorting
									THIS._cssdata.splice((cdindex + impnumber), 0, cssdata);
									
									//if there are any more imports to check, recur on the next one
									if(impnumber + 1 < importsheets.length)
									{
										stage5_checkImportForDataWrapper(impnumber + 1);
									}
									
									//otherwise call the local callback
									//with a zero increment value so that 
									//the iterator loops back on itself 
									//to check the stylesheet we just added
									else
									{
										localcallback(0);
									}
								});
							}
							
							//pass the first import index to stage5 to kick it off
							stage5_checkImportForDataWrapper(0);
						}
						
						//otherwise call the local callback straight away
						//with a standard increment value
						else 
						{
							localcallback(1);
						}
					}
				}
				
				//pass the first index to stage4 to kick it off
				stage4_checkStyleSheetForImports(0);
			}
			
			//6. check and request an import stylesheet
			function stage6_checkImportForData(cdcount, impcount, importobj, oncomplete)
			{
				//create a data object for the stylesheet and assign it an ssid
				var cssdata = {
					'tested' : BOOLEAN_FALSE,
					'owner' : '@import',
					'media' : MEDIA_ALL,
					'stylenode' : THIS._cssdata[cdcount].stylenode,
					'href' : importobj.href,
					'text' : ''
					};
					
				//save the media for this import
				cssdata.media = importobj.media;
				
				//get the context from the nearest ancestral non-import 
				var n = cdcount, parent = THIS._cssdata[n];
				while(parent.href == cssdata.href)
				{
					parent = THIS._cssdata[n--];
				}
				context = parent.media;
				
				//if the import itself has its own media specified, save that 
				//to the xmedia property, otherwise use the default value "all"
				//(I originally had this as media|context, but then I figured,
				// the context is not the import's media, is it?)
				cssdata.xmedia = importobj.hasownmedia ? importobj.media : MEDIA_ALL;
				
				//then contextualize the import's media
				cssdata.media = contextualizeMediaTypes(context, cssdata.media);
	
				//local finalizing function
				function finalizedata(fdata)
				{
					//if we have an error message, record it to the cssdata object
					//and nullify the stylenode reference
					//then if the error is an http error or "not css", set the media to "none"
					if(fdata.message != NULL_VALUE)
					{
						cssdata.message = fdata.message;
						cssdata.stylenode = NULL_VALUE;
						
						if(cssdata.message == ERROR_NOT_CSS || /^[1-9]{1,3}.*$/.test(cssdata.message))
						{
							cssdata.media = MEDIA_NONE;
						}
					}
					
					//otherwise strain and save the text, leaving valid imports in place for now
					//because we'll need to check for imports when its iteration comes round
					//in case an imported stylesheet also contains imports
					//the import statements will get removed when we do 
					//the final text processing operation to create the rules objects
					else 
					{ 
						cssdata.text =  strainStyleSheet(fdata.text, BOOLEAN_FALSE); 
					}
					
					//pass the data object to the oncomplete callback
					oncomplete(cssdata, cdcount, impcount);
				}
	
				//if the cssdata object already has this stylesheet href, 
				//mark it as a duplicate and don't make a request for it
				//this is particularly important to prevent infinite recursion
				//for example, where two stylesheets import each other
				if(arrayContains(THIS._cssdata, importobj.href, 'href') != NULL_VALUE)
				{
					//** how do we disable this duplicate when
					//** we don't have its stylesheet reference?
					
					//call the finalize function 
					//with a data object containing the redundent duplication message 
					//in the same format as would be returned by the request method
					finalizedata({
						'text' : '',
						'message' : MESSAGE_DUPLICATE
						});
				}
				
				//otherwise request the stylesheet, which sends back a data object
				//containing the text of a successful request, or an error message
				else
				{
					requestStyleSheet(importobj.href, finalizedata);
				}
			}
			
			//7. process the cssdata object to create the final cssRules array
			function stage7_processStyleSheetsData()
			{
				//now we're read start building the final cssRules data array
				//we'll have an array of objects each of which contains the raw stylesheet text
				//so what we have to do is parse each one to extract the style information
				for(var i=0; i<THIS._cssdata.length; i++)
				{
					//check if we already have this stylesheet data 
					//which we can only do for stylesheets that have an href
					//and will only be caused by duplication stylesheet includes
					//we already dealt with duplicate imports at the request stage
					//so this step is to find, mark and disable any duplicate top-level includes
					//we first have to check though that we're not comparing an existing duplicate
					//otherwise we could end up marking both instances as duplicates!
					//we use the arrayContains method to do this, which had to be modified so that
					//if it finds a match, it doesn't just return true, it returns the match it found,
					//which is a _cssdata object that we can check to see if it's already a duplicate
					if(THIS._cssdata[i].href)
					{
						var arycontains = arrayContains(THIS._stylesheets, THIS._cssdata[i].href, 'href');
						if(arycontains != NULL_VALUE && arycontains.message != MESSAGE_DUPLICATE)
						{
							//add duplication data to the debug stylesheets array
							THIS._stylesheets.push({
								'ssid' : THIS._cssdata[i].ssid,
								'href' : THIS._cssdata[i].href,
								'owner' : THIS._cssdata[i].owner,
								'media' : THIS._cssdata[i].media,
								'xmedia' : THIS._cssdata[i].xmedia,
								'stylenode' : NULL_VALUE,
								'rules' : 0,
								'message' : MESSAGE_DUPLICATE
								});
					
							//however if there are duplicate stylesheets, 
							//subsequently disabling one of them (ie. through stylesheet switching)
							//will cause the other one's rules to take effect, which the script
							//won't be aware of because its rules are not included
							//so since we don't have the option of just including duplicates 
							//because of the possibility of infinite recursion, 
							//what we'll do instead is just forcibly disable any duplicates we find
							if(THIS._cssdata[i].stylenode)
							{
								THIS._cssdata[i].stylenode.disabled = BOOLEAN_TRUE;
							}
							
							//continue to the next stylesheet
							continue;
						}
					}
					
					//if this data object has a message property then something went wrong
					//either a security error, or an http error while loading it
					//so just ignore it and continue to the next one
					if(typeof THIS._cssdata[i].message != TYPE_UNDEFINED) 
					{ 
						//record an entry to the debug stylesheets array
						THIS._stylesheets.push({
							'ssid' : THIS._cssdata[i].ssid,
							'href' : THIS._cssdata[i].href,
							'owner' : THIS._cssdata[i].owner,
							'media' : THIS._cssdata[i].media,
							'xmedia' : THIS._cssdata[i].xmedia,
							'stylenode' : THIS._cssdata[i].stylenode,
							'rules' : 0,
							'message' : THIS._cssdata[i].message
							});
						
						//continue to the next stylesheet
						continue; 
					}
					
					//send the data object to the css text parsing method
					//in which we'll actually build the cssRules data array
					//and return the number of rules we found, for the debug stylesheets array
					var rulecount = parseStyleSheetCSSText(THIS._cssdata[i]);
					
					//record an entry to the debug stylesheets array
					THIS._stylesheets.push({
						'ssid' : THIS._cssdata[i].ssid,
						'href' : THIS._cssdata[i].href,
						'owner' : THIS._cssdata[i].owner,
						'media' : THIS._cssdata[i].media,
						'xmedia' : THIS._cssdata[i].xmedia,
						'stylenode' : THIS._cssdata[i].stylenode,
						'rules' : rulecount,
						'message' : MESSAGE_OK
						});
				}
				
				//and once we get here we can delete the cssdata object
				//first setting it to null to ensure garbage collection in IE
				THIS._cssdata = NULL_VALUE;
				delete THIS._cssdata;
				
				//do a final sort of the _stylesheets array, putting it in ssid order
				THIS._stylesheets.sort(function(a, b) { return a.ssid - b.ssid; });
				
				//nullify and delete the ssidcounter
				THIS.ssidcounter = NULL_VALUE;
				delete THIS.ssidcounter;
				
				//if the watch setting is strictly true, watch for changes in disabled state
				if(watch === BOOLEAN_TRUE) { watchStyleSheets(); }
				
				//call the oncomplete callback, if defined
				if(typeof oncomplete == TYPE_FUNCTION) 
				{ 
					oncomplete(); 
				}
			}
		
			//0. if we have no data in _cssdata, jump straight to the final stage7
			//otherwise pass the first index to stage1 to kick everything off
			if(THIS._cssdata.length == 0) 
			{ 
				stage7_processStyleSheetsData(); 
			}
			else 
			{ 
				stage1_checkStyleSheetForDataWrapper(0); 
			}
		}
	}
	
	//get the raw text inside the page's <style> nodes
	function getRawStyleData(oncomplete)
	{
		//make a request for the page specified in the base property
		ajaxload(async, base,
		
		//if the load succeeds 
		function(code)
		{
			//re-get the "style" elements collection
			var stylenodes = getTheseElements('style');
			
			//save a copy of the html and split it by opening style tags
			var styleblocks = code.split(/<([^:]+:)?style[^>]*>/i);
			
			//delete the first member, which will be  
			//everything up to the first style element
			styleblocks.splice(0, 1);
			
			//now iterate and split each member by closing style tags
			//throw away the second member and keep the first
			//to leave us with just the css data inside it
			//in an array indexed by the element's position in the "style" collection
			//which we'll then save as a __css property of the source node,
			//just as we did for styleattrs, so that DOM changes aren't a problem
			for(var j=0; j<styleblocks.length; j++)
			{
				stylenodes[j].__css = styleblocks[j].split(/<\/([^:]+:)?style>/i)[0];
			}
			
			//////////////////
			//////////////////
			//////////////////
			// MODIFICATION //
			//////////////////
			//////////////////
			//////////////////

			//we don't need the styleblocks array anymore
			//so we can delete it to save a bit of memory
			//Every Little Helps :) (tm)
			// delete styleblocks;
			
			// `delete`
			// "strict mode forbids deleting plain names. 
			// delete name in strict mode is a syntax error"
			// source: 
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode
			
			//////////////////
			//////////////////
			//////////////////
			// MODIFICATION //
			//////////////////
			//////////////////
			//////////////////

			//call the callback
			oncomplete();
		},
		
		//there's no known reason why we should get failure
		//but if we do, the lack of .__css properties will be
		//handled where it occurs, so all we have to do here
		//is call the oncomplete callback as if nothing happens
		function()
		{
			oncomplete();
		});
	}
	
	//get the collection of all nodes that refer to stylesheets
	function getStyleSheetNodes()
	{
		//create the array
		var stylenodes = [];
		
		//begin by looking for xml-stylesheet processing instructions
		var kids = page.childNodes;
		for(var i=0; i<kids.length; i++)
		{
			if(kids[i].nodeType == 7 && kids[i].target.toLowerCase() == 'xml-stylesheet')
			{
				stylenodes.push(kids[i]);
			}
		}
		
		//then get a raw collection of all elements in all namespaces
		//or just all nodes if we're not in any form of XML, or the NS method fails
		var allnodes = getTheseElements('*');
		
		//then iterate through that to look for stylesheet nodes
		//link elements are included from any namespace according to their rel attribute, 
		//as are style elements from any namespace (isn't there an svg:style for example?)
		for(var i=0; i<allnodes.length; i++)
		{
			if((/link/i.test(allnodes[i].nodeName) 
					&& /stylesheet/i.test(allnodes[i].getAttribute('rel')))
				|| /style/i.test(allnodes[i].nodeName))
			{
				stylenodes.push(allnodes[i]);
			}
		}
		
		//return the final style nodes array
		return stylenodes;
	}
	
	//process a style node to get the preliminary data we need
	function processStyleNode(node, owner)
	{
		//create a data object for this stylesheet and assign it an ssid
		var cssdata = {
			'tested' : BOOLEAN_FALSE,
			'owner' : owner,
			'media' : MEDIA_ALL,
			'stylenode' : node,
			'href' : NULL_VALUE,
			'text' : ''
			};

		//if the owner is an xml-stylesheet, parse its data property
		//to create a dictionary of its pseudo attributes
		//we use match here instead of just splitting by delimiting whitespace, 
		//because the values themselves might contain whitespace
		//nb. xml-stylesheet regexes must be case-insensitive, to match implementations,
		//in which all aspects of an xml-stylesheet PI are case-sensitive
		if(/xml\-stylesheet/.test(owner))
		{
			var pseudoattrs = {}, 
				nodedata = node.data.match(/([a-z]+=[\'\"][^\'\"]*[\'\"])/gm);
			for(var i=0; i<nodedata.length; i++)
			{
				nodedata[i] = nodedata[i].split('=');
				pseudoattrs[nodedata[i][0]] = nodedata[i][1].substr(1, nodedata[i][1].length - 2);
			}
		}
		
		//except for safari or konqueror with nodes other than xml-stylesheet, because it always returns false
		//(so this is the exact opposite of what IE does!)
		//nb. though in fact, this /still/ always returns false unless the stylesheet has been
		//pre-disabled, by having a default disabled=disabled attribute, or by 
		//having its .disabled property set to false through scripting
		//if the node does have a disabled attribute, then node.sheet is null
		if((SAFARI || KONQUEROR || WEBKIT) && !/xml\-stylesheet/.test(owner))
		{
			var isdisabled = node.disabled;
		}
		
		//get the stylesheet's disabled state from the node's styleSheet/sheet property
		//we have to do this for IE because the node itself always returns not disabled
		//for others we only have to use it for xml-stylesheet,
		//but we may as well use it all the time to save a bit of code forking
		//nb. although we know this condition is IE vs. others, an object test is better
		//just in case any unknown devices have the same object reference
		else
		{
			//get the style node reference, and if its null set isdisabled to true
			//(which will happen in firefox for an alternate stylesheet that's 
			// missing its title attr and hence can never be switched on)
			//otherwise set it according to the style node's disabled state
			var disnode = node[typeof node.styleSheet != TYPE_UNDEFINED ? 'styleSheet' : 'sheet'],
				isdisabled = disnode == NULL_VALUE ? BOOLEAN_TRUE : disnode.disabled;
		}
		
		//in opera, the stylesheet returns as disabled if it applies to media
		//other than the one currently in force, such as "print" when the view is "screen"
		//so what we'll do is temporarily switch the media to whatever the current view is
		//then read its disabled property again, to find out if it's
		//really disabled or just applicable to a non-view media
		//this happens so fast that no visual change should be apparent
		if(OPERA && isdisabled && node.sheet.media.length > 0)
		{
			var realmedia = node.sheet.media.mediaText;
			node.sheet.media.mediaText = THIS._viewmedia;
			isdisabled = node.sheet.disabled;
			node.sheet.media.mediaText = realmedia;
		}
		
		//we don't want data from disabled stylesheets in the data set, 
		//unless this is author mode and the watch setting is null
		//so if it is (and it's not) add a message to the objeect to that effect, 
		//the presence of which will then prevent it from being proceessed any further
		//however don't stop here just yet because we want the href and media as well
		if(watch !== NULL_VALUE && isdisabled)
		{
			cssdata.message = MESSAGE_DISABLED;
		}

		//if the owner is an xml-stylesheet instruction
		//get the href from the pseudoattrs object and qualify it
		if(/xml\-stylesheet/.test(owner))
		{
			cssdata.href = qualifyHREF(pseudoattrs.href, base);
		}

		//or if the owner node is a link element get the href from its href attribute
		//we're using getAttribute so that we get the literal attribute value,
		//rather than a qualified value, so that we can qualify it ourselves
		//using the value for "base"; the second argument is IE proprietary
		//and the value 2 tells getAttribute to return the literal attribute value
		//rather than an "interpolated" value, ie. a property value, which is what 
		//IE normally returns for attributes, rather than returning attribute values: 
		//http://reference.sitepoint.com/javascript/Element/getAttribute
		else if(/link/i.test(owner))
		{
			cssdata.href = qualifyHREF(node.getAttribute('href', 2), base);
		}
		
		//otherwise it will be a style element
		else
		{
			//if it's not disabled or watch is null
			if(!isdisabled || watch === NULL_VALUE)
			{
				//if this is IE, the nodeData is actually CSS to IE, not just plain text like everything else
				//so it gets formatted like CSS (capitalized property names and type selectors, some value normalizing)
				//what we have to do then is refer to the raw page HTML we saved earlier
				//and grab the css text from that, not from this style element
				if(IEXPLORER)
				{
					//if we have no __css property for this node, record a network error
					//because that would mean we were unable to get the HTML during init
					if(typeof node.__css == TYPE_UNDEFINED)
					{
						cssdata.message = ERROR_NETWORK;
					}
					
					//otherwise grab that data and pass it to the strain method
					//to do some initial pre-parsing, but leaving valid imports in place for now
					else
					{
						cssdata.text += strainStyleSheet(node.__css, BOOLEAN_FALSE);
					}
				}
				
				//for any other browser
				else
				{
					//save the text content, doing some initial pre-parsing as we go
					//but leaving valid imports in place for now
					//we used to get the CSS data from the style node as simply "node.firstChild.nodeValue"
					//but running that on a stylesheet created as an <html:style> node 
					//within CodeBurner's results.xhtml page, the style node returned zero childNodes 
					//(because adding rules using insertRule doesn't create any;
					// if I modified the code to add them as text nodes then they did show up
					// - and still worked as CSS - but that's doesn't help us here)
					//so we need to be aware of that potential situation and handle it acccordingly
					//furthermore, when running it on a normal XHTML page, it missed rules
					//inside HTML comments or CDATA sections, because the main data is no longer 
					//the first child text node, it's the node data of the second child comment or cdata-section node
					//but we don't necessarily want to just put them back, because they might not apply - 
					//we need to match their inclusion against whether browsers actually apply them
					//and after cross-browser testing in applicable modes, we find the following:
					//
					//		/-------------------------------------------------------\
					//		| Browser		| HTML mode		  	| XHTML mode		|
					//		| 				| Comments	| CDATA	| Comments	| CDATA	| 
					//		|-------------------------------------------------------|
					//		| Opera 		| YES		| NO	| NO		| YES	|
					//		| Firefox		| YES		| NO	| NO		| YES	|
					//		| Safari		| YES		| NO	| YES		| YES	|
					//		| IE			| YES		| NO	| --		| --	|
					//		\-------------------------------------------------------/
					//
					//so, taking all of that into account, we made a modification to strainStyleSheet
					//that pre-removes the contents of CDATA or Comment sections,
					//according to mode and browser using the rules above, 
					//before parsing what's left as the complete CSS stylesheet
					
					//then we modified the code here to assemble a content string from all child nodes
					//including the comment or CDATA markers themselves
					//(so that the strain method would have some deletion hooks to work with)
					//using innerHTML proved unreliable because konqueror was entity-encoding it
					//and firefox was missing data in some situations - even though it was situations
					//where we didn't need it anyway, it still made me slightly uncomfortable
					//nb. the "CDATA" token is case-sensitive
					//"cdata" is invalid and causes an XML parsing exception
					for(var nodedata='', kids=node.childNodes, i=0; i<kids.length; i++)
					{
						switch(kids[i].nodeType)
						{
							case 3 : nodedata += kids[i].nodeValue; 						break;
							case 4 : nodedata += '<![CDATA[' + kids[i].nodeValue + ']]>'; 	break;
							case 8 : nodedata += '<!--' + kids[i].nodeValue + '-->'; 		break;
						}
					}
					cssdata.text += strainStyleSheet(nodedata, BOOLEAN_FALSE);
				}
			}
		}
		
		//get the media from its media attribute / pseudoattribute, 
		//or set to default if it doesn't have one defined 
		if(/xml\-stylesheet/.test(owner))
		{
			cssdata.media = typeof pseudoattrs.media != TYPE_UNDEFINED
							? pseudoattrs.media : MEDIA_ALL;
		}
		else
		{
			cssdata.media = node.getAttribute('media')
							? node.getAttribute('media') : MEDIA_ALL;
		}

		//then normalize the spacing between each delimited value
		//(the ',' + ' ' thing is to avoid compression)
		cssdata.media = cssdata.media.split(/,\s*/).join(',' + ' ');
		
		//and copy it to the xmedia property
		cssdata.xmedia = cssdata.media;
		
		//add this data object to the array
		THIS._cssdata.push(cssdata);
	}
	
	//make a request for a stylesheet
	function requestStyleSheet(href, oncomplete)
	{
		//create a request data object to return
		var requestdata = {
			'text' : '',
			'message' : NULL_VALUE
			};
		
		//make a request for the stylesheet, passing the async value
		ajaxload(async, href,
		
		//if it succeeds, save the text content to the data object
		//doing some initial pre-parsing as we do it
		function(responsetext, contype) 
		{ 
			//if we have a content type and it's not text/css
			//(local or chrome requests, with a status of 0,
			// also return a null or empty content type, 
			// so if we don't have one we'll just have to assume it's okay)
			if((typeof contype == TYPE_STRING && trim(contype) != '') 
				&& !/^(text\/css)/.test(contype))
			{
				//if the content type is text/html
				//scan it to see if it is in fact a server error page
				//and if it is see if we can extract the status error from its <title>
				//and if that succeeds record it to the data message property
				if(/^(text\/html)/.test(contype))
				{
					var matches = responsetext.match(/<title>([1-9]{1,3}[^<]+)<\/title>/i);
					if(matches && matches.length >= 2)
					{
						requestdata.message = matches[1];
					}
				}
				
				//if we haven't got a message, just set the "data is not css" message
				if(requestdata.message == NULL_VALUE)
				{
					requestdata.message = ERROR_NOT_CSS;
				}
			}
			
			//otherwise if we're good (or we have to assume we're good)
			//save the response text to the requestdata object
			else 
			{ 
				requestdata.text =  responsetext;
			}
			
			//call oncomplete with the request data
			oncomplete(requestdata);
		},
		
		//if the request fails for any reason
		function(statustext)
		{
			//save the status text message to the requestdata object
			requestdata.message = statustext;

			//call oncomplete with the request data
			oncomplete(requestdata);
		});
	}
	
	//extract @import statements from the raw text of a stylesheet
	function extractImportStatements(styletext)
	{
		//create the array for storing any we find
		var importsheets = [];
		
		//define regexes for matching import statements
		//which may include media definitions and queries
		var importreg = /@import\s*(?:url\s*\(\s*[\'\"]?|[\'\"])([^\'\"\)]+)(?:[\'\"]|[\'\"]?\s*\))([^;]*)(;|$)/ig;
		
		//look for @import statements in the text
		var matches = styletext.match(importreg);
		
		//if we have matches
		if(matches)
		{
			for(var i=0; i<matches.length; i++)
			{
				//extract and qualify the href
				var href = qualifyHREF(matches[i].replace(importreg, '$1'), base);
				
				//extract the media, from which we may have to trim 
				//leading space and residual close bracket, or set default
				var media = trim(trim(matches[i].replace(importreg, '$2')).replace(/^\)/, ''));

				//set the hasownmedia flag to true, indicating that 
				//the import statement had a media flag as part of it
				//this is used to differentiate the original media from a 
				//contextual media in the final data set
				var hasownmedia = BOOLEAN_TRUE;
	
				//then if it didn't in fact one, set this flag to false,
				//and the media itself to the default value "all"
				if(!media) 
				{ 
					hasownmedia = BOOLEAN_FALSE;
					media = MEDIA_ALL; 
				}
				
				//add to the importsheets array
				importsheets.push({
					'href' : href,
					'media' : media,
					'hasownmedia' : hasownmedia
					});
			}
		}
		
		//return the final array
		return importsheets;
	}
	
	//remove unwanted information from stylesheet text
	function strainStyleSheet(styletext, importsheets)
	{
		//css comments
		//this must come first because it expects multi-line data
		//and without that it will fail to remove complex comments
		//that contain lots of intermediate stars and slashes
		styletext = styletext.replace(/(\/\*([^*]|(\*+([^*/])))*\*+\/)/gm, '');
		
		//in HTML mode, delete anything inside and including CDATA markers
		//in XHTML mode but not webkit browsers, delete anything inside and including HTML comments
		//we do this because no supported browsers implement such rules (except for webkit as noted)
		//for more about this see processStyleNode()
		//(near the end - the notes preceding the last call to strainStyleSheet())
		//nb. the "CDATA" token is case-sensitive
		//"cdata" is invalid and causes an XML parsing exception
		if(!THIS._isXML)
		{
			styletext = styletext.replace(/(<\!\[CDATA\[([^\]]|(\]+([^>])))*\]+>)/gm, '');
		}
		if(THIS._isXML && (!(SAFARI || KONQUEROR || WEBKIT)))
		{
			styletext = styletext.replace(/(<\!\-\-([^\-]|(\-+([^>])))*\-+>)/gm, '');
		}
		
		//convert one or more contiguous tab to a single space
		//and any resulting multiple spaces to single spaces
		//we don't want to just remove them in case they're used in syntax
		//eg. the media query "screen		and		(color)" would otherwise be
		//converted to "screenand(color)", which would evaluate to "none"
		//of course this means we'll be left with whitespace in the stylesheet css text
		//but we do plenty of trimming when we parse it into properties
		//so that won't matter in the final analysis, it just means that
		//the css property may contain a space between each property:value; pair
		styletext = styletext.replace(/[\t]+/g, ' ').replace(/[ ][ ]/g, ' ');		
		
		//line-breaks
		styletext = styletext.replace(/[\r\n]/g, '');		
		
		//@charset and @namespace statements
		styletext = styletext.replace(/@(charset|namespace)[^;]+;/igm, '');	
		
		//if the importsheets flag is defined and true, remove @import statements
		if(typeof importsheets != TYPE_UNDEFINED && importsheets == BOOLEAN_TRUE)
		{
			styletext = styletext.replace(/@import[^;]+;/igm, '');	
		}
		
		//otherwise we need to check and remove any imports which are invalid
		//for imports to be valid they must be at the start of the stylesheet
		//so any which come after a block of normal CSS don't apply and get deleted
		else if(/@import[^;]+;/i.test(styletext))
		{
			//add split markers around each import statement and split by those markers
			//(IE doesn't support backreferences after split(), so we had to do this
			// to get data split by import statements without losing the statements themselves)
			var cssdata = styletext.replace(/(@import[^;]+;)/igm, '{SPLIT}$1{SPLIT}').split('{SPLIT}');

			//then clear the original text variable and iterate through the fragments
			//so we can re-compile the text with valid code only
			for(var styletext = '', nomoreimports = NULL_VALUE, i=0; i<cssdata.length; i++)
			{
				//don't include any fragments that are pure whitespace
				//because they'll throw our calculations off, beside being useless 
				if(trim(cssdata[i]) == '') { continue; }
				
				//if this fragment is an import statement
				if(/@import[^;]+;/i.test(cssdata[i]))
				{
					//if it's the first we've seen, indicate that they're still valid
					if(nomoreimports === NULL_VALUE) { nomoreimports = BOOLEAN_FALSE; }
					
					//if they're still valid,  add it to the compiled text
					if(nomoreimports === BOOLEAN_FALSE) { styletext += cssdata[i]; }
				}
				
				//or if this fragment is not an import statement
				//indicate that they're no longer valid
				//then add it to the compiled text
				else
				{
					nomoreimports = BOOLEAN_TRUE;
					styletext += cssdata[i];
				}
			}
		}
		
		//@font-face and @page declarations
		styletext = styletext.replace(/@(font\-face|page)[^\}]+\}/igm, '');
		
		//remove any remaining HTML comments or CDATA markers
		//(just the markers themselves, not their contents -
		// we've already deleted the ones that aren't valid)
		//nb. the "CDATA" token is case-sensitive
		//"cdata" is invalid and causes an XML parsing exception
		styletext = styletext.replace(/(<\!\-\-)|(\-\->)|(<\!\[CDATA\[)|(\]\]>)/gm, '');
		
		//trim and return the result
		return trim(styletext);
	}
	
	//parse the css text of a style sheet
	function parseStyleSheetCSSText(cssdata)
	{
		//do token replacements for generated content
		//to avoid confusion in case it contains any brace characters
		var gencontent = cssdata.text.match(/(content:[^;]+;)/igm);
		if(gencontent)
		{
			for(var g=0; g<gencontent.length; g++)
			{
				cssdata.text = cssdata.text.replace(gencontent[g], '[G' + g + ']');
			}
		}
		
		//strain and trim (including imports), then split the text by closing-brace characters
		cssdata.text = trim(strainStyleSheet(cssdata.text, BOOLEAN_TRUE)).split('}');
		
		//iterate through the resulting lines 
		//trim and split each one again, by the opening brace character
		for(var i=0; i<cssdata.text.length; i++)
		{
			cssdata.text[i] = trim(cssdata.text[i]).split('{');
			for(var j=0; j<cssdata.text[i].length; j++)
			{
				cssdata.text[i][j] = trim(cssdata.text[i][j]);
			}
		}
		
		//then iterate again through the resulting matrix
		//to convert any generated content tokens back to their real value
		if(gencontent)
		{
			for(var g=0; g<gencontent.length; g++)
			{
				for(var i=0; i<cssdata.text.length; i++)
				{
					for(var j=0; j<cssdata.text[i].length; j++)
					{
						cssdata.text[i][j] = cssdata.text[i][j].replace('[G' + g + ']', gencontent[g]);
					}
				}
			}
		}
		
		//count the number of rules we find so that we can
		//return that data back up to the debug stylesheets array
		var rulecount = 0;

		//we identify changes in media by an odd number of members in a group of text lines
		//beginning with the default media values from the stylesheet
		var currentmedia = cssdata.media,
			currentxmedia = cssdata.xmedia;
		
		//we identify changes in owner the same way
		var currentowner = cssdata.owner;
		
		//iterate through the text lines
		for(var i=0; i<cssdata.text.length; i++)
		{
			//if we have two members this is just a normal rule pair
			if(cssdata.text[i].length == 2)
			{
				//add this rule data to the cssRules array
				THIS._cssRules.push({
					'selector' : cssdata.text[i][0],
					'css' : cssdata.text[i][1],
					'media' : currentmedia,
					'xmedia' : currentxmedia,
					'owner' : currentowner.toLowerCase(),
					'href' : cssdata.href,
					'ssid' : cssdata.ssid
					});
					
				//add to the rulecount
				rulecount++;
			}
			//if we have three then the first is an opening @media declaration
			else if(cssdata.text[i].length == 3)
			{
				//set the new owner and media
				currentmedia = trim(cssdata.text[i][0].replace('@media', '')).toLowerCase();
				currentowner = '@media';
				
				//copy to currentxmedia to save the original value
				currentxmedia = currentmedia;
				
				//then adjust the media type if necessary to take account of the context
				//we only need to check as far as the containing style sheet
				//because its media has already been contextualized
				var context = cssdata.media;
				if(context == '') { context = MEDIA_ALL; }
				currentmedia = contextualizeMediaTypes(context, currentmedia);
					
				//add this rule to the cssRules array
				THIS._cssRules.push({
					'selector' : cssdata.text[i][1],
					'css' : cssdata.text[i][2],
					'media' : currentmedia,
					'xmedia' : currentxmedia,
					'owner' : currentowner,
					'href' : cssdata.href,
					'ssid' : cssdata.ssid
					});
					
				//add to the rulecount
				rulecount++;
			}
			//if we have one then it's closing an @media declaration
			//or it's an empty member after a stylesheets' final closing brace
			//either way, the context should now be the parent stylesheet
			else if(cssdata.text[i].length == 1)
			{
				currentmedia = cssdata.media;
				currentxmedia = cssdata.xmedia;
				
				currentowner = cssdata.owner;
			}
		}
		
		//return the number of rules we found
		return rulecount;
	}
	
	
	
	
	//-- private methods for building the browser-mode rules data array --//
	
	//create the data array of css style rules from all document stylesheets
	function createBrowserRulesData(oncomplete)
	{
		//get the collection of stylesheets from the specified context document
		//and convert it to an array so that we can splice it if necessary
		var stylesheets = arrayifize(page.styleSheets);
		
		//iterate through the collection and parse each stylesheet
		for(var i=0; i<stylesheets.length; i++)
		{
			//assign an index to this stylesheet
			stylesheets[i].__ssid = THIS.ssidcounter++;
			
			//if the stylesheets has an ownerNode property then this is a standard implementation
			//which we can parse using DOM 2 CSS properties and collections
			if(typeof stylesheets[i].ownerNode != TYPE_UNDEFINED)
			{
				//if this is safari 3 we cannot process xml-stylesheet, 
				//because it doesn't support the pseudo-attributes we need
				if(SAFARI3 && /xml\-stylesheet/.test(stylesheets[i].ownerNode.nodeName))
				{
					//add error data to the debug stylesheets array
					THIS._stylesheets.push({
						'ssid' : stylesheets[i].__ssid,
						'href' : qualifyHREF(stylesheets[i].href, base),
						'owner' : 'xml-stylesheet',
						'media' : MESSAGE_UNKNOWN,
						'stylesheet' : NULL_VALUE,
						'rules' : 0,
						'message' : MESSAGE_UNSUPPORTED_TYPE
						});
	
						//remove it from this array
						stylesheets.splice(i, 1);
						i --;
				}
			
				//otherwise try to parse the stylesheet as normal
				else
				{
					try
					{
						parseStyleSheet(
							stylesheets[i], 
							stylesheets[i].ownerNode.nodeName.toLowerCase(),
							//the trim probably isn't necessary, but better safe than sorry!
							stylesheets[i].media.length > 0 ? trim(stylesheets[i].media.mediaText) : MEDIA_ALL
							);
					}
					
					//if we fail just delete this stylesheet and carry on
					//the only known occurence is this exception is when
					//using the script within the chrome scope in Firefox
					//where a couple of extension stylesheets turned out
					//to have a null ownerNode, for reasons unknown
					catch(err)
					{
						//add error data to the debug stylesheets array
						//since this is so unlikely to happen, i'm being stingy 
						//with code and just making all the data "unknown"
						//of course this will make it harder for users 
						//to track down the offending stylesheet, 
						//but hey - that's what trial and error is for :-P
						//nb. the reason that the message is "unspecified error"
						//is that I don't actually know what causes it
						//so "unspecified" is the most I can tell you!
						THIS._stylesheets.push({
							'ssid' : stylesheets[i].__ssid,
							'href' : MESSAGE_UNKNOWN,
							'owner' : MESSAGE_UNKNOWN,
							'media' : MESSAGE_UNKNOWN,
							'stylesheet' : NULL_VALUE,
							'rules' : 0,
							'message' : ERROR_UNSPECIFIED
							});
	
						//remove it from this array
						stylesheets.splice(i, 1);
						i --;
					}
				}
			}
			
			//or if it has an owningElement property then this is IE's implementation
			//which we have to parse using IE's proprietary nastiness
			//well, I say "nastiness", it's not really all that bad,
			//and at least it doesn't do all the aggressive value normalization that firefox does
			//it's just the way it normalizes all selectors and property names to uppercase
			//which is annoying and ugly and pisses me off
			//it's bad enough that it does that for HTML tag names, 
			//but at least it has the excuse of that being the canonical form
			else if(typeof stylesheets[i].owningElement != TYPE_UNDEFINED)
			{
				parseIEStyleSheet(
					stylesheets[i], 
					stylesheets[i].owningElement.nodeName.toLowerCase(),
					//the trim probably isn't necessary, but better safe than sorry!
					trim(stylesheets[i].media) != '' ? trim(stylesheets[i].media) : MEDIA_ALL
					);
			}
		}
		
		//do a final sort of the _stylesheets array, putting it in ssid order
		//this is for IE's benefit which generates the ssids in occurence order
		//but builds the array in rule order; so this sort will bring it
		//into line with other browsers so they all output the same occurence order
		THIS._stylesheets.sort(function(a, b) { return a.ssid - b.ssid; });
		
		//nullify and delete the ssidcounter
		THIS.ssidcounter = NULL_VALUE;
		delete THIS.ssidcounter;
		
		//if the watch setting is true, watch for changes in disabled state
		if(watch == BOOLEAN_TRUE) { watchStyleSheets(); }
		
		//call the oncomplete callback, if defined
		if(typeof oncomplete == TYPE_FUNCTION) 
		{ 
			oncomplete(); 
		}
	}
	
	//parse an individual stylesheet using DOM 2 CSS
	function parseStyleSheet(sheet, owner, media)
	{
		//check if we already have this stylesheet data 
		//which we can only do for stylesheets that have an href
		//and will only be caused by duplicate stylesheet includes
		//we also have to check that the href is not the same as base
		//which can happen in firefox 2 for <style> elements, rather than href being null
		if(sheet.href && sheet.href != base)
		{
			var testhref = qualifyHREF(sheet.href, base);
			if(arrayContains(THIS._stylesheets, testhref, 'href') != NULL_VALUE)
			{
				//add duplication data to the debug stylesheets array
				THIS._stylesheets.push({
					'ssid' : sheet.__ssid,
					'href' : testhref,
					'owner' : owner,
					'media' : media,
					'stylesheet' : NULL_VALUE,
					'rules' : 0,
					'message' : MESSAGE_DUPLICATE
					});
					
				//however if there are duplicate stylesheets, 
				//subsequently disabling one of them (ie. through stylesheet switching)
				//will cause the other one's rules to take effect, which the script
				//won't be aware of because its rules are not included
				//so since we don't have the option of just including duplicates 
				//because of the possibility of infinite recursion, 
				//what we'll do instead is just forcibly disable any duplicates we find
				//(although infinite recursion will be prevented by the browser in this case,
				//it can still happen in IE because of the way we get the data
				//and so we have to do it here so that the data set is x-browser consistent)
				sheet.disabled = BOOLEAN_TRUE;
				
				//and we're done here
				return;
			}
		}
		
		//try to get the cssRules collection from this stylesheet
		//and pass it along with the other input references
		//to the standard rules collection parsing method
		try
		{
			//is this stylesheet disabled
			var isdisabled = sheet.disabled;
			
			//in opera, the stylesheet returns as disabled if it applies to media
			//other than the one currently in force, such as "print" when the view is "screen"
			//so what we'll do is temporarily switch the media to whatever the current view is
			//then read its disabled property again, to find out if it's
			//really disabled or just applicable to a non-view media
			//this happens so fast that no visual change should be apparent
			if(OPERA && isdisabled && sheet.media.length > 0)
			{
				var realmedia = sheet.media.mediaText;
				sheet.media.mediaText = THIS._viewmedia;
				isdisabled = sheet.disabled;
				sheet.media.mediaText = realmedia;
			}
		
			//if the stylesheet is not disabled							
			if(!isdisabled)
			{
				//count the number of ordinary rules
				for(var rules=sheet.cssRules, rulecount=0, i=0; i<rules.length; i++)
				{
					if(rules.item(i).type == 1) 
					{ 
						rulecount++; 
					}
					else if(rules.item(i).type == 4)
					{
						for(var subrules=rules.item(i).cssRules, j=0; j<subrules.length; j++)
						{
							//no need to recur further than this, 
							//because nested @media are not allowed
							if(subrules.item(j).type == 1) { rulecount++; }
						}
					}
				}
				
				//set the ok message for the debug stylesheet array
				var message = MESSAGE_OK;
			}
			
			//if it is disabled, set the rulecount to zero
			//and the message to "stylesheet is disabled"
			else
			{
				rulecount = 0;
				message = MESSAGE_DISABLED;
			}
			
			//add data to the debug stylesheets array
			//checking that the href is not the same as base
			//which can happen in firefox 2 for <style> elements, 
			//rather than href being null (which is what we want to record)
			THIS._stylesheets.push({
				'ssid' : sheet.__ssid,
				'href' : (sheet.href && sheet.href != base)
							? qualifyHREF(sheet.href, base) 
							: NULL_VALUE,
				'owner' : owner,
				'media' : media,
				'stylesheet' : sheet,
				'rules' : rulecount,
				'message' : message
				});

			//if it's not disabled, parse the stylesheet
			if(!isdisabled)
			{
				parseCSSRules(sheet, sheet.cssRules, owner, media);
			}
		}
		
		//it will only fail because of a security error
		//if the stylesheet is on a different domain
		catch(err) 
		{ 
			//add data to the debug stylesheets array
			//checking that the href is not the same as base
			//which can happen in firefox 2 for <style> elements, 
			//rather than href being null (which is what we want to record)
			THIS._stylesheets.push({
				'ssid' : sheet.__ssid,
				'href' : (sheet.href && sheet.href != base) 
							? qualifyHREF(sheet.href, base) 
							: NULL_VALUE,
				'owner' : owner,
				'media' : media,
				'stylesheet' : NULL_VALUE,
				'rules' : 0,
				'message' : ERROR_SECURITY
				});
		}
	}
	
	//parse a collection of css rules using DOM 2 CSS 
	//this creates an array that's in order of occurence, where rules in
	//import stylesheets that are declared at the top occur before 
	//rules inside the stylesheet, and rules in @media block occur where they occur
	function parseCSSRules(sheet, rules, owner, media)
	{
		//iterate through the rules collection
		//we're actually going to iterate separately three times
		//for @imports, rules, and media blocks
		//and do them separately so that we can control the order of execution
		//if don't do that then we'll may end up passing the wrong arguments back through
		//eg. an import will call it before the rules within a stylesheet
		//and we'll end up recording those rules with the import's media
		//we have to do the imports first so that the overall rule indices remain accurate
		//to their source order, which may be crucial when it comes to sorting
		for(i=0; i<rules.length; i++)
		{
			//save a shortcut reference
			rule = rules.item(i);
		
			//if it's an @import
			if(rule.type == 3)
			{
				//get the media from the rule itself
				//or if that's empty get it from the stylesheet's parent stylesheet
				//or if that's empty set it to default 
				media = rule.media.mediaText;
				if(media == '') 
				{ 
					//this exception handling is for safari, where if the parent
					//stylesheet is an @import then it doesn't have a media object
					//the media object belongs to its ownerRule object instead
					try { media = rule.parentStyleSheet.media.mediaText; }
					catch(err) { media = rule.parentStyleSheet.ownerRule.media.mediaText; }
				}
				if(media == '') { media = MEDIA_ALL; }
			
				//convert the value to lower case
				media = media.toLowerCase();
				
				//then adjust the media type if necessary to take account of the context
				//and so on for as many parent contexts as there are
				var parent = rule.parentStyleSheet;
				while(parent)
				{
					//this exception handling is for safari, where if the parent
					//stylesheet is an @import then it doesn't have a media object
					//the media object belongs to its ownerRule object instead
					try { var context = parent.media.mediaText; }
					catch(err) { context = parent.ownerRule.media.mediaText; }

					if(context == '') { context = MEDIA_ALL; }
					media = contextualizeMediaTypes(context, media);
					
					//this condition is to catch a difference in parent stylesheet reference
					//when the stylesheet object is an @import in safari
					if((SAFARI || KONQUEROR || WEBKIT) && !parent.parentStyleSheet && parent.ownerRule)
					{
						parent = parent.ownerRule.parentStyleSheet;
					}
					else
					{
						parent = parent.parentStyleSheet;
					}
				}
				
				//get the nested stylesheet reference from this rule
				//assign it an ssid, and then pass it back to the parseStyleSheet method
				//along with an owner name and media to save with the rule
				rule.styleSheet.__ssid = THIS.ssidcounter++;
				parseStyleSheet(rule.styleSheet, '@import', media);
			}
		}
		
		//now iterate again and look for normal rules
		for(var i=0; i<rules.length; i++)
		{
			//save a shortcut reference
			var rule = rules.item(i);
			
			//if this is a regular style rule
			if(rule.type == 1)
			{
				//if owner is "link", "style" or "xml-stylesheet" then this is a normal rule
				//(as opposed to being inside a @media or @import for which media was passed in as an argument)
				//so get the media from the rule's parent stylesheet
				//or if that's empty set it to default 
				//nb. we're splitting the media-getting routines into the rule-type conditions
				//rather than doing them all at once in this condition
				//because safari returns null for rule.parentRule
				if(/^(xml\-stylesheet|link|(([a-z]+:)?style))$/i.test(owner))
				{
					media = rule.parentStyleSheet.media.mediaText;
					if(media == '') { media = MEDIA_ALL; }
				
					//convert the value to lower case
					media = media.toLowerCase();
				}
				
				//we may have to parse the style.cssText to add !important to any !important rules
				//because in Opera (maybe others) the "!important" token itself is not included in the cssText
				//however we can get it from the getPropertyPriority method for each individual property
				//though it is quite a lot of farting about, it has to be done
				//we can't do it any later than now because we won't have the cssRule reference any more;
				//so ... begin by getting the cssText and stripping any line breaks 
				var styletext = rule.style.cssText.replace(/[\r\n]/g, ' ');
				
				//split the cssText by semi-colons
				styletext = styletext.split(';');
				
				//then iterate through the results and splt each one by its first colon
				for(var c=0; c<styletext.length; c++)
				{
					//this convoluted funkiness is because IE failed to return
					//any matches when a first-colon regex was used, so instead we split
					//by all colons and then join together any excess matches
					//even though IE doesn't actually run this particular bit of code anyway,
					//it was simpler just to use the same code pattern everywhere we need to do this
					styletext[c] = styletext[c].split(':');
					while(styletext[c].length > 2) { styletext[c][1] += ':' + styletext[c].pop(); }
								
					//if we only have one match, the most likely reason
					//is that the semi-colon split operation latched onto
					//a semi-colon that wasn't a property delimeter
					//probably it was inside generated content
					//and hence the value we're splitting doesn't contain a colon at all
					//so if that happens we'll just have to remove it and continue
					//it would happen sooner or later anyway for such a rule, so it's no ultimate loss
					if(styletext[c].length == 1) 
					{ 
						styletext.splice(c, 1);
						c--;
						continue; 
					}
					
					//add !important to the property definition if applicable
					//and if it doesn't already have that flag
					//(we need to check for an end-substring so that we don't get confused
					//	by a content property with "!important" in its text 
					// (which is possible, however improbable!))
					if(rule.style.getPropertyPriority(trim(styletext[c][0])) == 'important'
						&& !IMPORTANT_RULE.test(styletext[c][1]))
					{
						styletext[c][1] += ' !important';
					}
					
					//join it back together
					styletext[c] = styletext[c].join(':');
				}
				
				//and join the whole thing back together
				styletext = styletext.join(';');

				//add this rule object to the array
				//qualifying the href if it's not null
				THIS._cssRules.push({
					'selector' : rule.selectorText,
					'css' : styletext,
					'media' : media,
					'owner' : owner,
					'href' : sheet.href == NULL_VALUE ? NULL_VALUE : qualifyHREF(sheet.href, base),
					'ssid' : sheet.__ssid
					});
			}
		}
		
		//now iterate again and look for @media blocks
		for(i=0; i<rules.length; i++)
		{
			//save a shortcut reference
			rule = rules.item(i);
			
			//if it's an @media
			if(rule.type == 4)
			{
				//get the media from the rule itself
				//or if that empty get it from the parent stylesheet
				//		which is possible - Firefox and IE support "@media { ... }"
				//		treating it is "@media all"; however Opera and Safari reject
				//		such rules, not including them in the cssRules collection at all
				//or if that's empty set it to default 
				media = rule.media.mediaText;
				if(media == '') { media = rule.parentStyleSheet.media.mediaText; }
				if(media == '') { media = MEDIA_ALL; }
			
				//convert the value to lower case
				media = media.toLowerCase();
				
				//then adjust the media type if necessary to take account of the context
				//and so on for as many parent contexts as there are
				var parent = rule.parentStyleSheet;
				while(parent)
				{
					//this exception handling is for safari, where if the parent
					//stylesheet is an @import then it doesn't have a media object
					//the media object belongs to its ownerRule object instead
					try { var context = parent.media.mediaText; }
					catch(err) { context = parent.ownerRule.media.mediaText; }
					
					if(context == '') { context = MEDIA_ALL; }
					media = contextualizeMediaTypes(context, media);
					
					//this condition is to catch a difference in parent stylesheet reference
					//when the stylesheet object is an @import in safari
					if((SAFARI || KONQUEROR || WEBKIT) && !parent.parentStyleSheet && parent.ownerRule)
					{
						parent = parent.ownerRule.parentStyleSheet;
					}
					else
					{
						parent = parent.parentStyleSheet;
					}
				}
				
				//get the nested rules collection from this rule
				//and then pass it back to the parseCSSRules method
				//along with this stylesheet reference
				//and an owner name and media to save with the rule
				parseCSSRules(sheet, rule.cssRules, '@media', media);
			}
		}
		
		//for any other kind of rule we're not interested
	}

	//parse an individual stylesheet for IE
	function parseIEStyleSheet(sheet, owner, media, href)
	{
		//check if we already have this stylesheet data 
		//which we can only do for stylesheets that have an href
		//and will only be caused by duplication stylesheet includes
		//this is particularly necessary because it prevents infinite recursion
		//for example, where two stylesheets import each other
		if(sheet.href)
		{
			var testhref = qualifyHREF(sheet.href, base);
			if(arrayContains(THIS._stylesheets, testhref, 'href') != NULL_VALUE)
			{
				//add duplication data to the debug stylesheets array
				THIS._stylesheets.push({
					'ssid' : sheet.__ssid,
					'href' : testhref,
					'owner' : owner,
					'media' : media,
					'stylesheet' : NULL_VALUE,
					'rules' : 0,
					'message' : MESSAGE_DUPLICATE
					});
				
				//however if there are duplicate stylesheets, 
				//subsequently disabling one of them (ie. through stylesheet switching)
				//will cause the other one's rules to take effect, which the script
				//won't be aware of because its rules are not included
				//so since we don't have the option of just including duplicates 
				//because of the possibility of infinite recursion, 
				//what we'll do instead is just forcibly disable any duplicates we find
				sheet.disabled = BOOLEAN_TRUE;
				
				//and we're done here
				return;
			}
		}
		
		//create a temporary array for storing any imports we find
		//that we'll then pass back to this method at the end
		//we could just pass them back as soon as we find them
		//but storing them and doing it at the end ensures that
		//the original order is preserved for the debug stylesheets array
		var importsheets = [];	
		
		//is this stylesheet disabled
		var isdisabled = sheet.disabled;

		//if the stylesheet is not disabled							
		if(!isdisabled)
		{
			//first of all go through the imports collection
			for(var i=0; i<sheet.imports.length; i++)
			{
				//IE doesn't support @import with a media type
				//but they do still show up in the imports collection
				//even though they're not effective
				//so we have to check for this by testing the 
				//length of the import's rules collection
				//and if its zero just don't include the stylesheet
				if(sheet.imports[i].rules.length == 0) { continue; }
				
				//get the media from the owner stylesheet
				//or if that's empty set it to default
				media = trim(sheet.media);
				if(media == '') { media = MEDIA_ALL; }
				
				//get and qualify the href from the import
				//nb. we need to use a different variable name here
				//so that we don't affect the input href argument
				var ihref = qualifyHREF(sheet.imports[i].href, base);
					
				//add the impored stylesheet to the imports array
				//along with an owner reference, the effective media, and its href
				importsheets.push({
					'sheet' : sheet.imports[i], 
					'owner' : '@import', 
					'media' : media, 
					'href' : ihref
					});
			}
		}
		
		//if we have any imports, assign each one an ssid,
		//and then pass it back to this method
		//we do this before checking the other rules in this stylesheet
		//so that the overall rule indices accurately reflect source order
		if(importsheets.length > 0)
		{
			for(var i=0; i<importsheets.length; i++)
			{
				importsheets[i].sheet.__ssid = THIS.ssidcounter++;
				parseIEStyleSheet(
					importsheets[i].sheet, 
					importsheets[i].owner, 
					importsheets[i].media, 
					importsheets[i].href
					);
			}
		}

		//now we have to make a manul rules collection from the stylesheet's cssText
		//otherwise we won't be able to get info about @media blocks
		//because they're just not included in the rules collection at all
		try
		{
			//if the stylesheet is not disabled							
			if(!isdisabled)
			{
				//first copy the text
				var styletext = sheet.cssText;
				
				//remove any @import, @charset and @namespace statements
				styletext = styletext.replace(/@(import|charset|namespace)[^;]+;/igm, '');	
				
				//remove any @font-face and @page declarations
				styletext = styletext.replace(/@(font\-face|page)[^\}]+\}/igm, '');

				//do token replacements for generated content
				//to avoid confusion in case it contains any brace characters
				//this regex is different from the one we used in author mode
				//because IE6 normalizes generated content to have no quotes around it
				//and all versions put their expressions at the end of the group
				//but since we still have line breaks at this point, 
				//we can use the end of line marker to delimit the match expression
				//however we don't have line-breaks within a block of CSS
				//so just in case the ordering is not consistent
				//we'll make semi-colon an alternative delimiter
				var gencontent = styletext.match(/(content\s*:\s*[\'\"].*(;|$))/igm);
				if(gencontent)
				{
					for(var g=0; g<gencontent.length; g++)
					{
						styletext = styletext.replace(gencontent[g], '[G' + g + ']');
					}
				}
				
				//then trim and split the result by closing-brace characters
				styletext = trim(styletext).split('}');
				
				//iterate through the resulting lines 
				//trim and split each one again, by the opening brace character
				for(var i=0; i<styletext.length; i++)
				{
					styletext[i] = trim(styletext[i]).split('{');
					for(var j=0; j<styletext[i].length; j++)
					{
						styletext[i][j] = trim(styletext[i][j]);
					}
				}
				
				//then iterate again through the resulting matrix
				//to convert any generated content tokens back to their real value
				if(gencontent)
				{
					for(var g=0; g<gencontent.length; g++)
					{
						for(var i=0; i<styletext.length; i++)
						{
							for(var j=0; j<styletext[i].length; j++)
							{
								styletext[i][j] = styletext[i][j].replace('[G' + g + ']', gencontent[g]);
							}
						}
					}
				}
				
				//if href is undefined, get and qualify the href from the stylesheet, 
				//unless it's null or empty, in which case its null 
				//nb. we only really need to test empty, 
				//but I feel safer testing null as well
				if(typeof href == TYPE_UNDEFINED)
				{		
					href = (sheet.href == NULL_VALUE || sheet.href == '') 
							? NULL_VALUE 
							: qualifyHREF(sheet.href, base);
				}
				
				//now build a rules collection 
				var rules = []; 
				
				//we identify changes in media by an odd number of members in a group of text lines
				//beginning with the default media value from the stylesheet
				//if the value is empty then set it to default 
				var currentmedia = sheet.media;
				if(currentmedia == '') { currentmedia = MEDIA_ALL; }
	
				//we identify changes in owner the same way
				var currentowner = owner;
				
				//iterate through the text lines
				for(var i=0; i<styletext.length; i++)
				{
					//if we have two members this is just a normal rule pair
					if(styletext[i].length == 2)
					{
						rules.push({
							'selector' : styletext[i][0],
							'css' : styletext[i][1],
							'media' : currentmedia,
							'owner' : currentowner,
							'href' : href,
							'ssid' : sheet.__ssid
							});
					}
					//if we have three then the first is an opening @media declaration
					//which we can edit to get the actual media value
					else if(styletext[i].length == 3)
					{
						currentmedia = trim(styletext[i][0].replace('@media', '')).toLowerCase();
						currentowner = '@media';
						
						//adjust the media type if necessary to take account of the context
						var context = sheet.media;
						if(context == '') { context = MEDIA_ALL; }
						currentmedia = contextualizeMediaTypes(context, currentmedia);
						
						rules.push({
							'selector' : styletext[i][1],
							'css' : styletext[i][2],
							'media' : currentmedia,
							'owner' : currentowner,
							'href' : href,
							'ssid' : sheet.__ssid
							});
					}
					//if we have one then it's closing an @media declaration
					else if(styletext[i].length == 1)
					{
						currentmedia = sheet.media;
						if(currentmedia == '') { currentmedia = MEDIA_ALL; }
						
						currentowner = owner;
					}
				}
			
				//set the message for the debug array to "ok"
				var message = MESSAGE_OK;
			}
			
			//if it is disabled, set the message to "stylesheet is disabled"
			else
			{
				message = MESSAGE_DISABLED;
			}

			//if the stylesheet is not disabled
			//pass this custom rules collection to parseIECSSRules
			//which returns the final rule count
			if(!isdisabled)
			{
				var rulecount = parseIECSSRules(rules);
			}

			//add data to the debug stylesheets array
			THIS._stylesheets.push({
				'ssid' : sheet.__ssid,
				'href' : sheet.href 
							? qualifyHREF(sheet.href, base) 
							: NULL_VALUE,
				'owner' : owner,
				'media' : media,
				'stylesheet' : sheet,
				'rules' : !isdisabled ? rulecount : 0,
				'message' : message
				});
		}
		
		//it will only fail because of a security error
		//if the stylesheet is on a different domain
		catch(err) 
		{ 
			//add data to the debug stylesheets array
			THIS._stylesheets.push({
				'ssid' : sheet.__ssid,
				'href' : sheet.href 
							? qualifyHREF(sheet.href, base) 
							: NULL_VALUE,
				'owner' : owner,
				'media' : media,
				'stylesheet' : NULL_VALUE,
				'rules' : 0,
				'message' : ERROR_SECURITY
				});
		}
		
	}

	//parse a collection of css rules using IE proprietary nastiness
	//this creates an array in order of occurence, where rules in
	//import stylesheets that are declared at the top occur before 
	//rules inside the stylesheet, and rules in media block occur where they occur
	function parseIECSSRules(rules)
	{
		//store the number of rules that actually get added
		//we used to do this by counting the pre-cursor "rules" array 
		//but not all of them end up in the final cssRules array, 
		//which this count only includes
		var rulecount = 0;
		
		//iterate through the rules collection
		for(var i=0; i<rules.length; i++)
		{
			//if the selector is empty, unknown, or contains an unknown pseudo-node, 
			//just ignore it and continue on to the next rule
			//(IE has a cutely-obvious way of indicating unknown syntax in css :))
			if(rules[i].selector == '' 
				|| rules[i].selector == 'UNKNOWN' 
				|| rules[i].selector.indexOf(':unknown') != -1) { continue; }
			
			//add this rule object to the array, and along the way
			//parse the selectorText string to lowercase all the element type selectors
			//and parse the cssText string to lowercase all the property names
			THIS._cssRules.push({
				'selector' : lowercaseIETypeSelectors(rules[i].selector),
				'css' : lowercaseIEPropertyNames(rules[i].css),
				'media' : rules[i].media,
				'owner' : rules[i].owner,
				'href' : rules[i].href,
				'ssid' : rules[i].ssid
				});
			
			//increase the rule count
			rulecount ++;
		}
		
		//return the final rule count
		return rulecount;
	}



	
	//-- other private css-related methods --/
	
	//getCSSRules return all the rule objects that apply to an element
	//each of these is a custom object compiled with the most useful information
	//rather than actually being a cssRule object, so that the results are consistent cross browser
	function getCSSRules(element, media, accept, altstates, rules, inherited, ancestors)
	{
		//no processing of the first two arguments happens here
		//we require them to have been pre-processed before calling this

		//process the accept argument (if necessary)
		//it will never be undefined at this point, but it may still be a string
		//(when called by most public methods) or already an object 
		//(when called from a recursion of this method, or from its public equivalent)
		accept = processAcceptArgument(accept);

		//if rules is undefined or null, define a new array
		if(typeof rules == TYPE_UNDEFINED || rules == NULL_VALUE) { rules = []; }
		
		//if inherited is undefined or null, set it to false
		if(typeof inherited == TYPE_UNDEFINED || inherited == NULL_VALUE) { inherited = BOOLEAN_FALSE; }
		
		//if ancestors is undefined or null, create an array beginning with this element
		//we'll maintain an array of all the elements we check
		//which we'll need when it comes to determine the selector specificity
		//so that we can reject those that don't apply
		if(typeof ancestors == TYPE_UNDEFINED || ancestors == NULL_VALUE) 
		{ 
			ancestors = [element]; 
			
			//if the element has a style attribute, and the "attributes" setting is true,
			//add a temporary member to the end of the cssRules array containing its data
			//this means its index value will place it as the very last rule to be defined
			//which in source-order specificity terms is exactly right
			//however in IE getAttribute('style') returns an object not a string
			//which we can deal with in the createStyleAttributeRule method
			//but it means that it will always pass this test, even when
			//the element has no style attribute; if that happens, or if the 
			//style attribute is empty, the create method will return null
			//so we save the return value and test it before adding it to the array
			if(attributes == BOOLEAN_TRUE && element.getAttribute('style'))
			{
				var stylerule = createStyleAttributeRule(element);
				if(stylerule != NULL_VALUE)
				{
					THIS._cssRules.push(stylerule);
				}
			}
		}
		//otherwise add this element to the existing array
		else 
		{ 
			ancestors.push(element); 
		}
		
		//now iterate through all the stored cssRules
		for(var i=0; i<THIS._cssRules.length; i++)
		{
			//if the rule doesn't match the input media criteria, we don't want it
			if(!mediaMatches(media, THIS._cssRules[i])) { continue; }
			
			//if this is a temporary style attribute rule
			//and the element argument is the original input element reference
			//create a nodes array containing just the input element
			//so that it passes straight through as a single found match
			//and set the altstate variable for it to false
			//because style attributes apply to all states
			//this will make sure that its properties are correctly sorted
			if(THIS._cssRules[i].owner == '@style' && element == ancestors[0]) 
			{ 
				var nodes = [element],
					altstate = BOOLEAN_FALSE;
			}
			
			//otherwise, see if this selector matches any elements
			else 
			{ 
				//if the altstates argument is true, do a pre-search for this element
				//with the original selector, not edited for pseudo-classes
				//so we can compare to know whether it matched without editing, or only with editing
				if(altstates == BOOLEAN_TRUE)
				{
					for(var altstate = BOOLEAN_TRUE,
							allnodes = getElementsBySelector(THIS._cssRules[i].selector),
							j=0; j<allnodes.length; j++)
					{
						if(allnodes[j] == element)
						{
							altstate = BOOLEAN_FALSE;
							break;
						}
					}
				}
				//or if altstates is false then all matches will be by default, not alt states
				else 
				{ 
					altstate = BOOLEAN_FALSE; 
				}
				
				//now do the real search, and if the altstates argument is true, 
				//remove pseudo-classes except not() from the test selector;
				//otherwise pass it in unedited
				nodes = getElementsBySelector(
							altstates == BOOLEAN_TRUE
								? THIS._cssRules[i].selector.replace(REGEX_PSEUDO_CLASSES_EXCEPT_NOT, '')
								: THIS._cssRules[i].selector
								); 
			}
			
			//if we have matches, search them looking for the input element reference
			if(nodes.length > 0)
			{
				for(var j=0; j<nodes.length; j++)
				{
					//and if we find it add the specified rule to the rules array
					if(nodes[j] == element)
					{
						//create an inheritance path array, which must be a copy not a reference
						//otherwise when we come to copy it into the output, 
						//it will be the same (its final state) every time
						//we'll also do it in reverse so that 
						//we get an array that's in top-down DOM order
						var inheritance = [];
						if(inherited)
						{
							for(var a=ancestors.length-1; a>0; a--)
							{
								inheritance.push(ancestors[a]);
							}
						}
						
						//create a rule object to add to the array, starting with 
						//the selectors, css, index in the rule array,
						//or altstates is true and the selector only applies to an altstate
						//a placeholder for its specificity (which we'll work out 
						//once we've got all the rules), its current inheritance path 
						//and a flag to indicate whether it actually applies to the element in its current state
						//all of which we need irrespective of whether they're included
						//in the accept dictionary; so for any that are not, 
						//we'll delete them at the end once all the other processing is done
						var ruleobj = {
							'selector' : THIS._cssRules[i].selector,
							'css' : THIS._cssRules[i].css,
							'index' : i,
							'specificity' : [0,0,0,0],
							'inheritance' : inheritance,
							'altstate' : altstate
							};				
							
						//then add the properties which are optional and only included 
						//if they're listed in the accept dictionary, or it's "*";
						//apart from "properties" which we deal with later
						for(var optionalprops = ['media','xmedia','owner','ssid','href'], 
								k=0; k<optionalprops.length; k++)
						{
							if(accept == '*' || typeof accept[optionalprops[k]] != TYPE_UNDEFINED)
							{
								//we need this condition because the "xmedia"
								//property is only available in author mode
								if(typeof THIS._cssRules[i][optionalprops[k]] != TYPE_UNDEFINED) 
								{
									ruleobj[optionalprops[k]] = THIS._cssRules[i][optionalprops[k]];
								}
							}
						}
						
						//add this rule object to the rules array
						rules.push(ruleobj);
						
						//we'll only find it once!
						break;
					}
				}
			}
		}
		
		//if this element has a parent element, recur on that
		//so that we get inherited rules as well
		if(element.parentNode && element.parentNode.nodeType == 1)
		{
			return getCSSRules(element.parentNode, media, accept, altstates, rules, BOOLEAN_TRUE, ancestors);
		}

		//otherwise we can proceed to process the finished rules array
		else
		{
			//if we have no rules we can just return the empty array and we're done
			//as well as saving some process, this also means that we can save adding
			//a condition to the bit at the bottom which removes any added @style rule
			//which we'd otherwise have to check against (THIS._cssRules.length > 0)
			if(rules.length == 0) { return rules; }
			
			//first we have to sort it so it's in primary order of specificity
			//with a secondary order by source index, and a tertiary order by inheritance chain depth
			//so begin by iterating through the rules to get their specificities
			for(var i=0; i<rules.length; i++)
			{
				//extract the selector from this rule and split into individuals
				var selectors = rules[i].selector.split(',');
				
				//now we need to pass each selector to the getSelectorSpecificity method
				//(unless it's inherited in which case it has zero specificity)
				//so we get an array of all the specificities that apply to the overall selector
				for(var specs=[], j=0; j<selectors.length; j++)
				{
					specs.push(
						rules[i].inheritance.length > 0 
								? [0,0,0,0] 
								: getSelectorSpecificity(selectors[j])
								);
				}

				//now inverse sort the resulting array, so that the largest is first
				specs.sort(function(a, b)
				{
					if(a[0] !== b[0]) { return b[0] - a[0]; }
					if(a[1] !== b[1]) { return b[1] - a[1]; }
					if(a[2] !== b[2]) { return b[2] - a[2]; }
					return b[3] - a[3];
				});

				//then save the highest value, because obviously that's the one
				//that determines the specificity of the rule's properties to this element
				rules[i].specificity = specs[0];
			}
			
			//now we have the specificity data we can sort the rules array by it
			rules.sort(function(a, b)
			{
				//if the specificity values are the same
				if(a.specificity.toString() === b.specificity.toString()) 
				{ 
					//if the source index values are also the same, 
					//sort on inverse inheritance depth
					//so that the highest elements come before the deepest elements
					if(a.index === b.index) 
					{ 
						return b.inheritance.length - a.inheritance.length; 
					}
					
					//otherwise sort on source index
					return a.index - b.index; 
				}
				
				//otherwise sort on specificity
				if(a.specificity[0] !== b.specificity[0]) 
				{ 
					return a.specificity[0] - b.specificity[0]; 
				}
				if(a.specificity[1] !== b.specificity[1]) 
				{ 
					return a.specificity[1] - b.specificity[1]; 
				}
				if(a.specificity[2] !== b.specificity[2]) 
				{ 
					return a.specificity[2] - b.specificity[2]; 
				}
				return a.specificity[3] - b.specificity[3];
			});
			
			//if "properties" is included in the accept dictionary, or its "*"
			//we need to add and then sort the individual properties for the rules
			//"sort" in this case means to organise the data so that each member 
			//is a further object with value and status properties, rather than just a value
			//ie. each has the form {"color":{"value":"red","status":"active"} rather than just {"color":"red"}
			//and the "status" value can be "active", "cancelled" or "inactive" (for altstate rules)
			//this replaces what used to be separate properties,xproperties,nproperties objects
			//the second argument instructs the method to do that sort,
			//which if it's false will only return an unsorted properties object,
			//which setting is used by the getCSSStyleSheetRules method
			if(accept === "*" || typeof accept.properties != TYPE_UNDEFINED)
			{
				rules = addSortedProperties(rules, BOOLEAN_TRUE);
			}
			
			//if accept is not "*", then for each of the options 
			//"selector","css","index","specificity", "inheritance" and "altstate", 
			//if the accept dictionary didn't include it, delete it from each rule object
			//first nullifying it to ensure garbage collection in IE
			if(accept !== "*")
			{
				for(var i=0; i<rules.length; i++)
				{
					for(var props=['selector','css','index','specificity','inheritance','altstate'], 
							j=0; j<props.length; j++)
					{
						if(typeof accept[props[j]] == TYPE_UNDEFINED)
						{
							rules[i][props[j]] = NULL_VALUE;
							delete rules[i][props[j]];
						}
					}
				}
			}

			//if we added a temporary rule object 
			//for the element's style attribute, remove it again
			if(THIS._cssRules[THIS._cssRules.length - 1].owner == '@style')
			{
				THIS._cssRules.splice(THIS._cssRules.length - 1, 1);
			}
		
			//and return the final rules array
			return rules;
		}
	}
	
	//create a rule object for the cssRules array 
	//that represents an element's style attribute
	function createStyleAttributeRule(element)
	{
		//if this is internet explorer we can't get the css text from the style attribute
		//because the style attributes return a style object, not a string,
		//even when you use the incorrectly-documented second argument 
		//[see: http://reference.sitepoint.com/javascript/Element/getAttribute#compatibilitysection]
		//but we can extract it from the element's outerHTML using match() (lol)
		//and then pass it to the lowercaseIEPropertyNames method to normalize the case
		if(IEXPLORER)
		{
			//just in case this is XML and not HTML, we'll wrap it in try..catch
			//though it's very unlikely that if this is XML it will have a style attribute
			//I suppose it might be SVG, but then IE doens't support SVG. VML maybe?
			//whatever .. it's as well to be safe rather than allow a possible exception
			try
			{
				//here we can rely on the fact that IE normalizes the outerHTML
				//such that attributes are always a lowercase name and double-quoted
				//and any quotes inside values like url() are removed
				//remembering to split by the first closing angle bracket, so that we only get
				//the html of the element's opening tag, not everything inside it as well!
				//if the element doesn't have a style attribute the match will be null
				//so in that case set styletext to an empty string
				var matches = element.outerHTML.split('>')[0].match(/.*style\s*=\s*\"([^\"]*)\".*/im);
				var styletext = matches ? lowercaseIEPropertyNames(matches[1]) : '';
			}
			
			//in the unlikely event it fails for the reason noted, we just return an empty string
			catch(err) { styletext = ''; }
		}
		
		//for any other browser we can just grab it from the style attribute as text
		else 
		{ 
			styletext = element.getAttribute('style'); 
		}
		
		//if the styletext is empty, return null
		if(styletext == '') 
		{ 
			return NULL_VALUE; 
		}
		
		//else create a rule object
		var ruleobj = 
		{
			//the empty string selector signifies a style attribute, for user reference,
			//and particularly so that the the getSelectorSpecificity method can identify it
			'selector': '',
			'css' : styletext,
			'media': MEDIA_ALL,
			'owner' : '@style',
			'href' : NULL_VALUE,
			//the infinity value means that in a numerical sort it will always come out at the end
			//though tbh that isn't something I planned, it just worked out nicely that way :)
			//it had to be a number for consistency with other values, but any number I choose 
			//might conflict with an actual stylesheet, even a really high number
			//an alternative I considered was to use -1, which would be safe from conflict,
			//however that value already has a special meaning - it's a valid argument to
			//getCSSStyleSheetRules, which means "no specific stylesheet"
			'ssid' : Infinity
		};
			
		//add xmedia only in author mode
		if(mode == MODE_AUTHOR) 
		{ 
			ruleobj.xmedia = ruleobj.media; 
		}
			
		//return the finished rule object
		return ruleobj;
	}
	
	//extract the individual properties for a set of rules from each rule's css text 
	//then sort them according to which ones are precedent and which cancelled out
	//to add status flags - "active","cancelled" or "inactive" - to each property
	//this methods assumes that the rules set is already in order of specificity 
	//and that each one has information about its inheritance; as created by getCSSRules
	function addSortedProperties(rules, dosort)
	{
		//run through the rules
		for(var i=0; i<rules.length; i++)
		{
			//parse the css text to create a properties object
			rules[i].properties = parsePropertyText(
				rules[i].css, 
				{}, 
				(typeof rules[i].inheritance != TYPE_UNDEFINED 
					&& rules[i].inheritance.length > 0)
				);
				
			//create a re-organised copy in which each property 
			//is now a sub-object with "value" and "status" properties
			//then mark each status as "active" by default
			rules[i].allproperties = {};
			for(var j in rules[i].properties)
			{
				rules[i].allproperties[j] = {
					'value' : rules[i].properties[j].property,
					'status' : STATUS_ACTIVE
					};
			}
			
			//if the dosort argument is true
			if(dosort)
			{
				//if the altstate flag for this rule is true
				//change all the status flags to "inactive" 
				if(rules[i].altstate == BOOLEAN_TRUE)
				{
					for(var ip in rules[i].allproperties)
					{
						if(!rules[i].allproperties.hasOwnProperty(ip)) { continue; }

						rules[i].allproperties[ip].status = STATUS_INACTIVE;
					}							
				}
				
				//otherwise iterate from the start of the current collection up to now
				//in order to find and mark the cancelled properties
				else
				{
					for(var j=0; j<i; j++)
					{
						//for each of the properties in the earlier object
						for(var jp in rules[j].allproperties)
						{
							if(!rules[j].allproperties.hasOwnProperty(jp)
								|| rules[j].allproperties[jp].status != STATUS_ACTIVE) { continue; }
							
							//for each of the properties in this object
							for(var ip in rules[i].allproperties)
							{
								if(!rules[i].allproperties.hasOwnProperty(ip)
									|| rules[i].allproperties[ip].status != STATUS_ACTIVE) { continue; }
								
								//if we encounter this current properties in the earlier 
								//properties objects, change its status to "cancelled"
								//we do this for both inheritable and non-inheritable properties;
								//or rather: we do it for inheritable properties, or non-inheritable
								//properties where the previous rule is not inherited;
								//but we don't need to do that additional testing
								//because only non-inherited properties will be included
								//in the output of inherited rules
								if(jp == ip)
								{
									rules[j].allproperties[jp].status = STATUS_CANCELLED;
						
									//there will only be one
									break;
								}
							}
						}
					}
				}
			}
		}
		
		//if the dosort argument is true
		if(dosort)
		{
			//now we need to run through the cancelled properties 
			//to deal any with !important rules, so...
			for(var i=0; i<rules.length; i++)
			{
				//we're not interested in inherited properties, because they have no specificity
				//and therefore !important rules do not take precedence
				if(rules[i].inheritance.length > 0) { continue; }
				
				//run through the cancelled properties to look for !important
				//(we need to check for an end-substring so that we don't get confused
				//	by a content property with "!important" in its text),
				for(var j in rules[i].allproperties)
				{
					if(!rules[i].allproperties.hasOwnProperty(j)
						|| rules[i].allproperties[j].status != STATUS_CANCELLED) { continue; }
					
					//and if we find one
					if(IMPORTANT_RULE.test(rules[i].allproperties[j].value))
					{
						//it will take precedence
						var precedence = i;
	
						//then run through every subsequent object 
						//to look for later properties with the same name, 
						for(var x=i+1; x<rules.length; x++)
						{
							//and if we find a cancelled one that also has !important
							if(typeof rules[x].allproperties[j] != TYPE_UNDEFINED
								&& rules[x].allproperties[j].status == STATUS_CANCELLED
								&& IMPORTANT_RULE.test(rules[x].allproperties[j].value))
							{
								//then it will over-take precedence
								precedence = x;
							}
						}
						
						//then iterate from here to find the property identified as having precedence
						for(var x=i; x<rules.length; x++)
						{
							//and once we've found the property with precedence, 
							//change its status back to "active"
							if(x == precedence)
							{
								rules[x].allproperties[j].status = STATUS_ACTIVE;
								
								//and any earlier active instances of that property to which we did the same thing
								//then need their status changed back from "active" to "cancelled"
								for(var y=0; y<x; y++)
								{
									if(typeof rules[y].allproperties[j] != TYPE_UNDEFINED
										&& rules[y].allproperties[j].status == STATUS_ACTIVE)
									{
										rules[y].allproperties[j].status = STATUS_CANCELLED;
									}
								}
							}
							
							//and for any other instance of that property that's already "active"
							//update its status to "cancelled"
							else
							{
								if(typeof rules[x].allproperties[j] != TYPE_UNDEFINED
									&& rules[x].allproperties[j].status == STATUS_ACTIVE)
								{
									rules[x].allproperties[j].status = STATUS_CANCELLED;
									
									//there will only be one
									break;
								}
							}
						}
					}
				}
			}
			
			//now we need to deal with the interaction of shorthand and longhand properties
			//basically, if a shorthand property definition has precedence, then any earlier
			//longhand definitions of the same type are cancelled out; however the reverse 
			//is not true - if a longhand property takes precedence, then any earlier shorthand
			//properties remain listed as having precedence, because some of their properties still will
			//for eg. if a set of properties (in order, across the stack) goes: 
			//"margin-left -> margin" then the "margin-left" is cancelled out; but if it goes:
			//"margin -> margin-left" then the "margin" is not cancelled out; 
			//so...
			for(var i=0; i<rules.length; i++)
			{
				//for each active value in the properties object
				for(var j in rules[i].allproperties)
				{
					if(!rules[i].allproperties.hasOwnProperty(j)
						|| rules[i].allproperties[j].status != STATUS_ACTIVE) { continue; }
	
					//if this is a shorthand property definition
					//which we know simply by whether we have a longhands list for it
					if(typeof LONGHAND_PROPERTIES[j] != TYPE_UNDEFINED)
					{
						//run through every rule up to and including this one
						for(var x=0; x<=i; x++)
						{
							//run through the list of longhand properties that this shorthand property defines
							//and if we find an active one in the rule's properties, change its status to "cancelled"
							//we don't need to check whether the property is inhertiable for inherited rules
							//because non-inheritable properties won't even be listed (obviously)
							for(var p=0; p<LONGHAND_PROPERTIES[j].length; p++)
							{
								var longhand = LONGHAND_PROPERTIES[j][p];
								if(typeof rules[x].allproperties[longhand] != TYPE_UNDEFINED
									&& rules[x].allproperties[longhand].status == STATUS_ACTIVE)
								{
									//if we're examining this rule, only cancel out longhand properties 
									//that are defined earlier in the rule than the shorthand property we're inspecting
									//so to make that disctinction we need to work out the index of
									//the shorthand and longhand properties in question, if it's this rule
									//nb. this presumes that for..in iterates in order of the property being added
									//which is a correct presumption in all supported browsers
									if(x == i)
									{
										var n = 0;
										for(var q in rules[x].allproperties)
										{
											if(!rules[x].allproperties.hasOwnProperty(q)) { continue; }
											
											if(q == j) { var jindex = n; }
											if(q == longhand) { var pindex = n; }
											
											n++;
										}
									}
									
									//so go ahead and cancel the rule, if:
									//	we're not examining this rule;
									//	or the longhand property is earlier than the shorthand property, 
									//and: the rule does not have !important
									//(earlier checks will have already determined which important rule 
									// takes precedence, if there's more than one; we just have to 
									// make sure here that we don't mark it as cancelled, if applicable)
									if((x < i || pindex < jindex) 
										&& !IMPORTANT_RULE.test(rules[x].allproperties[longhand].value))
									{
										rules[x].allproperties[longhand].status = STATUS_CANCELLED;
									}
								}
							}
						}
					}
				}
			}
		}
		
		//iterate one more time to do final maintenance on the modified rules array
		for(var i=0; i<rules.length; i++)
		{
			//do a final sweep through the properties objects
			//converting any to null that have no members
			for(var j in rules[i])
			{
				if(!rules[i].hasOwnProperty(j)) { continue; }
				
				//we have to spell-out these conditions, not use a regex
				//so that they get converted by the compression routine
				//otherwise we'll end up with a condition that 
				//no longer matches the post-compression property names
				if((j == 'properties' || j == 'allproperties') && howmany(rules[i][j]) == 0)
				{
					rules[i][j] = NULL_VALUE;
				}
			}
			
			//copy allproperties to properties then delete it
			rules[i].properties = rules[i].allproperties;
			delete rules[i].allproperties;
			
			//then if the dosort argument is false
			//run through the properties and rationalize each property
			//so that it goes back to being simple name/value pairs
			//and we lose the status property, because none of them have been checked
			if(!dosort)
			{
				for(var k in rules[i].properties)
				{
					if(!rules[i].properties.hasOwnProperty(k)) { continue; }

					rules[i].properties[k] = rules[i].properties[k].value;
				}				
			}
		}
			
		//return the modified rules array
		return rules;
	}

	//get the specificity of a selector, using the rules defined in the CSS3 spec
	//http://www.w3.org/TR/css3-selectors/#specificity
	function getSelectorSpecificity(selector)
	{
		//create an object for storing the scores, 
		//ordered by specificity class: [style, id, class, type]
		var scores = [0,0,0,0];
		
		
		//if the selector is an empty string, this indicates a style attribute
		//so add 1 to the style score and return the scores array straight away
		if(selector === '')
		{
			scores[0] += 1;
			return scores;
		}
		
			
		//create an edited versions of the input selector 
		//that's stripped of all attribute selectors
		//which we can use to avoid confusion with attribute values
		//that look like other selectors, for example [href="index.html"] 
		//might otherwise be confused with a class selector ".html"
		var editedselector = selector.replace(REGEX_ATTR_SELECTORS, '');
		
		//look for ID selectors, which have the highest specificity category
		//use the selector that's been stripped of attribute selectors,
		//to avoid confusion with attribute values containing # symbols
		//and we should also check for valid characters and a valid ID pattern
		//nb. although "." is allowed in an ID value, 
		//we'd never be able to test it with an ID selector
		//because it will just be interpreted as an ID.class selector
		//matches from this regex will also include any pseudo-class or pseudo-elements
		//that immediately follow the ID selector, but that's doesn't matter
		var matches = editedselector.match(REGEX_ID_SELECTORS);
		
		//add the number of matches (if any) to the id score
		if(matches) { scores[1] += matches.length; }
		
		
		//look for class selectors, in almost exactly the same way 
		//and with the same caveats as an ID selector, except that
		//the valid syntax and pattern is slightly different
		var matches = editedselector.match(REGEX_CLASS_SELECTORS);
		
		//add the number of matches (if any) to the class score
		if(matches) { scores[2] += matches.length; }
		
		
		//look for attribute selectors in the unedited selector, 
		//these are the easiest to detect because there's 
		//no possibility of confusing them with anything else
		matches = selector.match(REGEX_ATTR_SELECTORS);
		
		//add the number of matches (if any) to the class score
		if(matches) { scores[2] += matches.length; }


		//look for any pseudo-class - except :not, which isn't counted
		//use the selector that's been stripped of attribute selectors
		//since there's a limited number of pseudos, we can test for each one specifically
		//nb. this will let through some fake permutations, like 
		//"only-child" or "first-last-of-type", but I don't think that's worth worrying about
		var matches = editedselector.match(REGEX_PSEUDO_CLASSES_EXCEPT_NOT);
		
		//add the number of matches (if any) to the class score
		if(matches) { scores[2] += matches.length; }
		
		
		//look for element type selectors, which is by far the hardest to do
		//because it's so easily confused for other types of selector
		//because it has no distinguishing tokens of its own, only the lack of them
		//so to begin with we'll use the selector that's been stripped of attribute selectors
		//then remove all pseudo-classes except :not(), and all pseudo-elements,
		//(but remove the actual word ":not", because XML element names are allowed to 
		//  contain colons and it would otherwise look like an element called ":not")
		//remove any namespace prefix (at the start of the selector, or inside a :not bracket)
		//and remove any ID or class selectors
		//then finally (if there's anything left!) check for valid tag name characters 
		var typeonlyselector = editedselector.replace(REGEX_PSEUDO_CLASSES_EXCEPT_NOT, '')
											 .replace(REGEX_PSEUDO_ELEMENTS, '')
											 .replace(/(:not)/ig, '')
											 .replace(/(^|\()([_a-z0-9-\.\\]+\|)/ig, '$1')
											 .replace(REGEX_ID_SELECTORS, '')
											 .replace(REGEX_CLASS_SELECTORS, '');
		var matches = typeonlyselector.match(/([_a-z0-9-:\\]+)/ig);
		
		//add the number of matches (if any) to the type score
		if(matches) { scores[3] += matches.length; }
		
		
		//and last but not least, look for pseudo-elements
		//use the selector that's been stripped of attribute selectors
		//then we can identify them easily and specifically, given such a limited range
		var matches = editedselector.match(REGEX_PSEUDO_ELEMENTS);
		
		//add the number of matches (if any) to the type score
		if(matches) { scores[3] += matches.length; }
		
		
		//return the final scores array
		return scores;
	}
	
	//parse a selectorText string for IE to lowercase the element type selectors
	function lowercaseIETypeSelectors(selectorstring)
	{
		//temporarily tokenize attribute selectors so that 
		//any all-uppercase attribute values are not affected
		var attrselectors = selectorstring.match(/(^|[^\(])(\[[^\]]+\])($|[^\)])/ig);
		if(attrselectors)
		{
			for(var a=0; a<attrselectors.length; a++)
			{
				//we only want the data in $2, but we don't have that much 
				//control over match(), so we'll have to edit them manually
				if(attrselectors[a].charAt(0) != '[') 
				{ 
					attrselectors[a] = attrselectors[a].substr(1, attrselectors[a].length - 1);
				}
				if(attrselectors[a].charAt(attrselectors[a].length -1) != ']')
				{
					attrselectors[a] = attrselectors[a].substr(0, attrselectors[a].length - 1);
				}
				//then convert the selector into a token
				selectorstring = selectorstring.replace(attrselectors[a], '{a' + a + '}');
			}
		}
		//do the same thing with class and ID selectors
		var cidselectors = selectorstring.match(/([#\.][a-z]+[_a-z0-9-:\\]*)/ig);
		if(cidselectors)
		{
			for(var c=0; c<cidselectors.length; c++)
			{
				selectorstring = selectorstring.replace(cidselectors[c], '{c' + c + '}');
			}
		}
		
		//now convert any pure uppercase element names to lowercase
		selectorstring = selectorstring.replace(/([A-Z1-6]+)/g, function(a) { return a.toLowerCase(); });
		
		//then reconvert the attribute selector and 
		//class/id selector tokens back to their original selectors
		if(attrselectors)
		{
			for(a=0; a<attrselectors.length; a++) 
			{ 
				selectorstring = selectorstring.replace('{a' + a + '}', attrselectors[a]); 
			}
		}
		if(cidselectors)
		{
			for(c=0; c<cidselectors.length; c++) 
			{ 
				selectorstring = selectorstring.replace('{c' + c + '}', cidselectors[c]); 
			}
		}
		
		//and return the edited selector		
		return selectorstring;
	}
	
	//parse a cssText string for IE to lowercase the property names
	function lowercaseIEPropertyNames(styletext)
	{
		//split the css text by semi-colons
		styletext = styletext.split(';');
		
		//iterate through the resulting properties
		for(var j=0; j<styletext.length; j++)
		{
			//split the property by its first colon to get the name and value
			//this convoluted funkiness is because IE failed to return
			//any matches when a first-colon regex was used, so instead we split
			//by all colons and then join together any excess matches
			var matches = styletext[j].split(':');
			while(matches.length > 2) { matches[1] += ':' + matches.pop(); }
			
			//if we only have one match, the most likely reason
			//is that the semi-colon split operation latched onto
			//a semi-colon that wasn't a property delimeter
			//probably it was inside generated content
			//and hence the value we're splitting doesn't contain a colon at all
			//so if that happens we'll just have to remove it and continue
			if(matches.length == 1) 
			{ 
				styletext.splice(j, 1); 
				j--; 
				continue; 
			}
			
			//trim them both and convert the property name to lower case
			matches[0] = trim(matches[0]).toLowerCase();
			matches[1] = trim(matches[1]);
			
			//then join them back together with consistent spacing
			styletext[j] = matches[0] + ': ' + matches[1];
		}
		
		//join them all back together with consistent spacing and return the reformated string
		//nb. the smei-colon and space are separated out so that we can universally compress "; " to ";"
		return styletext.join(';' + ' ');
	}

	//parse the selector text of an individual style rule
	//to create an array of individual selectors
	function parseSelectorText(selectorstring)
	{
		//create an array of selectors to return
		var selectors = [];
		
		//if the selectorstring is empty just return the empty array
		if(selectorstring == '') { return selectors; }
		
		//split the selector by commas
		selectorstring = selectorstring.split(',');
		
		//iterate through and add each trimmed selector to the array
		for(var j=0; j<selectorstring.length; j++)
		{
			selectors.push(trim(selectorstring[j]));
		}
		
		//return the selectors array
		return selectors;
	}
	
	//parse the properties text of an individual style rule 
	//to create object members in property/value pairs
	function parsePropertyText(styletext, properties, inherited)
	{
		//if the css text is empty return the object unchanged
		if(styletext == '') { return properties; }
		
		//parse all line-breaks out of the string
		styletext = styletext.replace(/[\r\n]/gm, '');
		
		//split the css text by semi-colon to get individual property definitions
		styletext = styletext.split(';');
		
		//now iterate through that array and create an object member for each one
		//counting the number of properties as we go so we can create a length property
		for(var i=0; i<styletext.length; i++)
		{
			//trim this value and continue if it's empty
			styletext[i] = trim(styletext[i]);
			if(styletext[i] == '') { continue; }
			
			//then split the property by its colon to get the name and value
			//this convoluted funkiness is for IE's benefit, which failed to return
			//any matches when a first-colon regex was used, so instead we split
			//by all colons and then join together any excess matches
			var matches = styletext[i].split(':');
			while(matches.length > 2) { matches[1] += ':' + matches.pop(); }
			
			//if we only have one match, the most likely reason
			//is that the semi-colon split operation latched onto
			//a semi-colon that wasn't a property delimeter
			//probably it was inside generated content
			//and hence the value we're splitting doesn't contain a colon at all
			//so if that happens we'll just have to ignore it and continue
			if(matches.length == 1) { continue; }
			
			//trim the first match and save it to a key variable
			var key = trim(matches[0]);

			//if the rule is not inherited, or the property is inheritable
			if(!inherited || (inherited && typeof INHERITED_PROPS[key] != TYPE_UNDEFINED))
			{
				//don't overwrite an existing rule if it has !important
				//unless it was an inherited rule, or 
				//unless this rule also has !important
				//(we need to check for an end-substring so that we don't get confused
				//	by a content property with "!important" in its text)
				if(typeof properties[key] == TYPE_UNDEFINED 
					|| !IMPORTANT_RULE.test(properties[key].property)
					|| properties[key].inherited == BOOLEAN_TRUE
					|| IMPORTANT_RULE.test(matches[1]))
				{
					//save this value to the properties array
					//along with an inherited flag
					properties[key] = {
						'property' : trim(matches[1]),
						'inherited' : inherited
						};
						
				}
			}
		}
		
		//return the modified properties object
		return properties;
	}
	
	//compare two media strings to see if the context affects the test type
	//and if so adjust the value of the test string accordingly
	//this is for cases where, for example, a <link media="screen"> contains "@media all"
	//and therefore the actual media that applies to those rules is "screen" not "all"
	//or where the context actually precludes the test type, for example <link media="print"> 
	//containing "@media screen", in which case we return "none"
	function contextualizeMediaTypes(context, types)
	{
		//convert the context string to an object
		var contextTypes = lexiconize(context, ',');
		
		//we're not currently testing for media query context
		//so remove and save any media query from the types string
		//so that we don't get confused with them
		var mediaQuery = /([ \t]and.*$)/i,
			matches = types.match(mediaQuery),
			typesQuery = (matches ? matches[0] : '');
		//we have to remove any "only" token so that we can do comparisons
		//against the media-types string that remains, but this means
		//that any such token will be lost permanently from the reported media
		//that's basically okay though because it doesn't affect how they evaluate
		types = types.replace(mediaQuery, '').replace(/only[ \t]+/i, '');
	
		//if the contextTypes object contains "all" then any inner types are okay
		//so just rejoin the types string to its saved media query and return it unmodified
		if(typeof contextTypes['all'] != TYPE_UNDEFINED)
		{
			return types + typesQuery;
		}
	
		//otherwise we have to to check each type against the context
		//so first split and trim the types string into individual media types
		types = types.split(',');
		for(var i=0; i<types.length; i++) 
		{ 
			types[i] = trim(types[i]); 
		}
		
		//then iterate through the types
		for(var i=0; i<types.length; i++)
		{
			//firstly, if the media type is "all"
			//then all the context media types apply here
			//so add them all individually to the types array
			//making sure we avoid duplication and not including media queries
			if(types[i] == MEDIA_ALL)
			{
				for(var m in contextTypes)
				{
					if(!contextTypes.hasOwnProperty(m)) { continue; }
					
					if(arrayContains(types, m) == NULL_VALUE && !/[\(\)]/.test(m))
					{
						types.push(m);
					}
				}
			}
	
			//then if the context does not contain this media type
			//then this media type either doesn't apply in context (so delete it from the array)
			//or it's "all" in which case we've already added the individual context types (so do nothing)
			if(typeof contextTypes[types[i]] == TYPE_UNDEFINED)
			{
				types.splice(i, 1);
				i --;
			}
		}
		
		//if the types array is now empty then 
		//the context has precluded the test type entirely
		//so if that's the case add the value "none" to the array
		//so that it ends up getting returned as "none [+ media query]"
		if(types.length == 0)
		{
			types.push(MEDIA_NONE);
		}
		
		//rejoin the types array, add back any media query, and return it
		//nb. the comma and space are separated like this to avoid compression
		return types.join(',' + ' ') + typesQuery;
	}
	
	//compare a media types array argument with the media types of a css rules
	//to return true of false by whther the rule matches the argument criteria
	function mediaMatches(media, rule)
	{
		//get the rule's media property and convert it to an object
		//so that we can easily test it as typeof mediaTypes[media]
		var mediaTypes = lexiconize(rule.media, ',');
		
		//begin by assuming no match
		var matches = BOOLEAN_FALSE;
		
		//then iterate through the input array of media types to look for at least one match
		//which is all we need for the rule to match the media criteria
		for(var j=0; j<media.length; j++)
		{
			//we have a match if this rule includes at least one of the specified media
			//or the specified media is "all" and the rule's media isn't "none"
			//or the rule's media contains "all" and the specified media isn't "none"
			//(this allows us to get collections of rules that don't apply to any media, 
			// as well as the collections that apply to one or more)
			if(typeof mediaTypes[media[j]] != TYPE_UNDEFINED
				|| (typeof mediaTypes[MEDIA_NONE] == TYPE_UNDEFINED && media[j] == MEDIA_ALL)
				|| (typeof mediaTypes[MEDIA_ALL] != TYPE_UNDEFINED) && media[j] != MEDIA_NONE)
			{
				matches = BOOLEAN_TRUE;
				break;
			}
		}

		//return the result
		return matches;
	}
	
	//detect the current view media 
	//this will only work on HTML pages, but it's better than nothing!
	function getViewMedia()
	{
		//set screen as default in case we can't get the value
		var viewmedia = MEDIA_SCREEN;
		
		//wrap all this in exception handling 
		//in case we're in an environment where it fails
		try
		{
			//begin by creating a test node
			//it's ID will match an ID selector in the test stylesheet we create
			//with a display value that's different from the one we'll define there
			//since we're setting it in .style it will have enough specificity
			//to override the stylesheet value, even though that has !important
			//we have to insert this node before the body's first child, we can't append to body
			//because it's not yet closed, and trying to append to an unclosed element
			//throws an error in IE7/8 (KB927917)
			var pagebody = page.getElementsByTagName('body').item(0);
			var testmedianode = pagebody.insertBefore(page.createElement('span'), pagebody.firstChild);
			testmedianode.id = 'cssutilitiestest'+'medianode';
			testmedianode.style.display = 'inline';

			//create the array of all CSS media types; the list is a delimited string which is split here
			//cos that worked out to less code than declaring an array of separate strings :)
			var mediaTypes = MEDIA_TYPES_LIST.split(',');
			
			//we see a failure condition in Safari 3 and Konqueror, where it
			//applies the stylesheet rule all the time, irrespective of applicable media,
			//and this manifests in it returning whichever type is first in the array
			//so to catch that we'll seed the array with a fake value we can check against
			mediaTypes.splice(0, 0, 'fake');
			
			//create a stylesheet and add a rule for a test node we're going to create
			//we do this differently depending on whether we're IE or everyone else
			//because the techniques we're using are mutually exclusive to those browsers
			//we'll define a display style that's different from the test node's default
			//using !important to give it the highest possible specificity,
			//and a convoluted library-specific ID value, to avoid conflict
			//with any existing styles and elements on the test document
			if(IEXPLORER)
			{
				//create a new stylesheet and add the rule using its proprietary technique
				var viewmediastylesheet = page.createStyleSheet();
				viewmediastylesheet.addRule('#cssutilitiestest'+'medianode', 'display:block !important;');
			}
			else
			{
				//create a style node and add the rule as a child text node
				var viewmedianode = page.getElementsByTagName('head').item(0).appendChild(page.createElement('style'));
				viewmedianode.setAttribute('type', 'text/css');
				viewmedianode.appendChild(page.createTextNode('#cssutilitiestest'+'medianode{display:block !important;}'));
			
				//now get a reference to the stylesheet we just created from the document.styleSheets collection
				//using the stylesheet rather than the original stylenode makes it work in Webkit
				var viewmediastylesheet = page.styleSheets[page.styleSheets.length - 1];
			}
			
			//now iterate through the CSS media types to test each one in turn
			for(var i=0; i<mediaTypes.length; i++)
			{
				//set the stylesheet media to this media type
				if(IEXPLORER) { viewmediastylesheet.media = mediaTypes[i]; }
				else { viewmediastylesheet.media.mediaText = mediaTypes[i]; }
				
				//if the test node is now taking on the display property
				//that was specified in the test stylesheet
				//then we know that the specified media applies to the current view :-)
				if((IEXPLORER && testmedianode.currentStyle.display == 'block')
					|| (!IEXPLORER && page.defaultView.getComputedStyle(testmedianode, '').getPropertyValue('display') == 'block'))
				{
					viewmedia = mediaTypes[i];
					break;
				}
			}
			
			//remove the test node and stylesheet
			testmedianode.parentNode.removeChild(testmedianode);
			if(IEXPLORER) { viewmedianode = viewmediastylesheet.owningElement; }
			viewmedianode.parentNode.removeChild(viewmedianode);
		}
		
		//silently fail [and set media back to default]
		catch(err) { viewmedia = MEDIA_SCREEN; }
		
		//if the returned value is "fake" then it's been caught by our seeding trap
		//so if that happens we'll just have to reset back to the default again
		if(viewmedia == 'fake') { viewmedia = MEDIA_SCREEN; }
		
		//return the final value
		return viewmedia;
	}
	
	//watch a collection of stylesheets for their disabled state to change
	//and when one of them does, re-initialize the script
	//we used to have a few different approaches for different browsers, but we couldn't rely on them
	//for example - in opera and firefox we can watch the disabled state of each stylesheet's ownerNode 
	//by extending the Object watch() method to the ownerNode elements, and that's virtually instantaneous 
	//but it won't cover view-menu stylesheet switching, which toggles the disabled state 
	//of the stylesheet itself, not its owner node; and we can't guarantee that any other browser
	//won't be implementing some extension or browser feature that works in the same way
	//so we can't take a chance of having innacurate data, we'll just have to use the timer
	//so in fact only Safari defaults to a different method, and that's only because the timer method
	//won't work, because disabled stylesheets don't show up in the stylesheets collection at all
	//of course once we've safely implemented the timer method, we could still use the other techniques
	//as well, but what's the point, just for a slightly faster response, it doesn't warrant the additional code
	function watchStyleSheets()
	{
		//so begin by creating an optimized data set
		//so we've got less to look at in each timer iteration
		//and thereby minimize the timer's CPU load
		for(var livesheets=[], i=0; i<THIS._stylesheets.length; i++)
		{
			//for author mode we use the stylenode.styleSheet/sheet references  
			//(or just the stylenode for safari);
			//or for browser mode we use the stylesheet references directly 
			var stylesheet = mode == MODE_AUTHOR
							 ? (THIS._stylesheets[i].stylenode == BOOLEAN_FALSE || THIS._stylesheets[i].stylenode == NULL_VALUE)
							 	? NULL_VALUE
							 	: (SAFARI || KONQUEROR || WEBKIT)
							 		? THIS._stylesheets[i].stylenode
							 		  //nb. although we know this condition is IE vs. others, an object test is better
							 		: THIS._stylesheets[i].stylenode[typeof THIS._stylesheets[i].stylenode.styleSheet != TYPE_UNDEFINED ? 'styleSheet' : 'sheet']
							 : THIS._stylesheets[i].stylesheet;
							 
			//ignore null stylesheets, such as duplicates,
			//or those we couldn't read for security reasons
			if(stylesheet == NULL_VALUE) { continue; }

			//save the stylesheet reference, and its current disabled state
			livesheets.push({
				'stylesheet' : stylesheet, 
				'disabled' : stylesheet.disabled 
				});
		}
		
		//for safari and konqueror in browser mode, 
		//disabled stylesheets don't show up in the document stylesheets collection at all
		//so what we do to detect the change is assign an ident to the owner node of each one
		//and then create a timer that assigns new idents to any stylesheet node that doesn't have one
		//and thereby it knows that something's changed because a new ident will appear
		//or an existing ident will disappear, due to stylesheets appearing and disappearing
		//from the document stylesheets collection. 
		//actually in safari, a change in the disabled state of a stylesheet causes its ownerNode to fire a
		//DOMSubtreeModified event in response to the addition or removal of that node from the DOM
		//so we culd detect that change, and use it as a springboard for re-initialization
		//but that would mean code forking for safari and konqueror, which is arguably a waste of code
		//since this method works for both; the only real difference is that the subtree modified
		//technique would be faster (virtually instant), but again, it's not really worth it for the extra code
		if((SAFARI || KONQUEROR || WEBKIT) && mode == MODE_BROWSER)
		{
			//function that iterates through the stylesheets collection
			//and assign an ident to any owner node that doesn't already have one
			function createStyleSheetIdents()
			{
				for(var idents=[], dsheets=page.styleSheets, i=0; i<dsheets.length; i++)
				{
					if(typeof dsheets[i].ownerNode.__ident == TYPE_UNDEFINED)
					{
						dsheets[i].ownerNode.__ident = new Date().getTime() + '' + Math.round(Math.random() * 10000);
					}
					idents.push(dsheets[i].ownerNode.__ident); 
				}
				return idents;
			}
			
			//assign the initial control idents then start the watch timer
			var controlidents = createStyleSheetIdents(), 
				watcher = window.setInterval(function()
			{
				//assign new idents as applicable
				var currentidents = createStyleSheetIdents();
				
				//if either of the ident arrays has changed
				if(controlidents.join() != currentidents.join())
				{
					//clear the timer then re-initialize, calling any stored init callback
					window.clearInterval(watcher);
					THIS.init(typeof THIS.initcallback != TYPE_UNDEFINED ? THIS.initcallback : NULL_VALUE);
				}
			
			}, WATCHER_SPEED_TIMER);
		}

		//for everybody else we'll use a timer to watch the disabled property
		//of all the valid stylesheets or stylenodes in the debug stylesheets array
		else
		{
			//start a watch timer, saving a reference we can stop it with
			//I actually did find a complete set of techniques for watching changes
			//in the disabled state of stylesheets without resorting to setInterval
			//however they all worked off the state of the ownerElement, but browsers'
			//built-in stylesheets switching (eg. the Style menu in Opera)
			//work off the disabled property of the stylesheet itself, not its owner node
			//so all of that is unuseable, and a timer it has to be :-(
			//I did consider adding it as well, just so that we get faster responses
			//but what's the point? it's just a whole bunch more code to little real benefit
			var watcher = window.setInterval(function()
			{
				//iterate through the optimized stylesheets set 
				for(var i=0; i<livesheets.length; i++)
				{
					//if the current disabled state differs from the stored state
					if(livesheets[i].stylesheet.disabled != livesheets[i].disabled)
					{
						//clear the timer then re-initialize, calling any stored init callback
						window.clearInterval(watcher);
						THIS.init(typeof THIS.initcallback != TYPE_UNDEFINED ? THIS.initcallback : NULL_VALUE);
						
						//set a flag to break the iteration
						var dobreak = BOOLEAN_TRUE;
					}
					
					//this break is crucial, to prevent multiple changes
					//from firing multiple re-initializations
					//it's basically doing the same job as the buffer
					//used for other browsers, but in a different way
					if(typeof dobreak != TYPE_UNDEFINED) { break; }
				}
			
			}, WATCHER_SPEED_TIMER);
		}
	}



	
	//-- private general utility methods --//
	
	//wrapper for Selectors APIs
	function getElementsBySelector(selector)
	{
		//manually filter out pseudo-elements, which of course never directly 
		//match an element reference, but some query implementations let them through
		//eg. DOMAssistant in IE, and the native implementation in Safari 3
		if(REGEX_SINGLE_PSEUDO_ELEMENT.test(selector))
		{
			var selectors = selector.split(',');
			for(var i=0; i<selectors.length; i++)
			{
				if(REGEX_SINGLE_PSEUDO_ELEMENT.test(selectors[i]))
				{
					selectors.splice(i, 1);
					i--;
				}
			}
			selector = selectors.join(',');
		}
		
		//if the selector is now empty return zero matches
		if(trim(selector) == '') { return []; }
		
		//nb. whichever selectors api method we use
		//we're going to silently fail around calls to it
		//so that we don't get errors from invalid selectors
		//the only place where we do catch and throw an explicit error
		//is where we can establish that a library we need just isn't there
		
		//if the api property is false then we've already established
		//that the browser has native support for querySelectorAll
		//and it hasn't been set to true to specify that the
		//fallback library function should be used for everyone
		if(api == BOOLEAN_FALSE) 
		{
			try { return page.querySelectorAll(selector); }
			catch(err) { return []; }
		}
		
		//otherwise, if we have a qsa function 
		//defined [and pre-tested], then call and return that
		if(typeof qsa == TYPE_FUNCTION)
		{
			try { return qsa(selector, page); }
			catch(err) { return []; }
		}
		
		//otherwise use the fallback library function
		try 		
		{ 
			//if the library isn't there at all, throw the missing sapi error
			if(typeof Selector != TYPE_FUNCTION) 
			{ 
				throw(new Error(FATAL_ERROR_MISSING_SAPI)); 
			}
			
			//in IE6, Selector sometimes returns undefined instead of an array
			//for selectors containing some pseudo-classes, like :hover
			//I haven't clearly established why (it isn't the colon causing regex failure
			//because other pseudos like :active don't display the same behavior), 
			//but anyway, to prevent unduev errors reaching the end user or developer, 
			//we'll catch that situation and return an empty array instead
			//oddly enough though, this doesn't seem to prevent it from matching
			//the selectors it returns undefined for correctly against their element
			//so it must be a different test that causes it, not the one that matches it!?
			var r = Selector(selector, page);
			return typeof r == TYPE_UNDEFINED ? [] : r;
		}
		catch(err) 
		{ 
			//if the error is the missing sapi error we threw for the missing library
			//then allow it to be output to the console
			if(err.message == FATAL_ERROR_MISSING_SAPI) { throw(err); }
			
			//otherwise silently fail as normal
			return []; 
		}

		//we return an empty array after a query method silent exception
		//which will usually be because it doesn't like the selector
		//either it doesn't understand it, or the selector is wrong or mangled in some way
	}
	
	//get an array of elements specified by tagname or "*"
	function getTheseElements(tagname)
	{
		//get a collection of the specified elements 
		//and convert it to an array so we can use array methods on it
		//use a namespaced method if appropriate so that for any given tagname 
		//we look in all namespaces, allowing us to support things like "svg:style"
		//as well as explicitly-namespaced HTML elements like "html:link"
		try
		{
			var thesenodes = arrayifize(
								THIS._isXML
									? page.getElementsByTagNameNS('*', tagname)
									: page.getElementsByTagName(tagname)
									);
		}
		//just in case anything goes wrong, create an empty array
		//this is just for paranoid safety - there's no known reason why it shoud fail
		catch(err) { thesenodes = []; }
		
		//we may need to filter out comments, because IE includes them in its "*" collection!
		//so in fact what we'll do is just exclude anything that's not an element
		//in case there's anything else it stupidly adds that I don't know about
		//[i spoke too soon...] if the page contains any custom elements, 
		//IE also adds their closing tag as an additional node to the collection!!
		//so we'll have to filter those out as well by checking for "/" at the start of the tag name
		//interestingly enough, all browsers except Opera convert custom element tag names 
		//to the canonical uppercase form in HTML; fwiw I think Opera is right - they're not HTML elements
		//so there's no reason to implement the canonical form; but other browsers probably
		//aren't thinking that deeply, they're probably just doing it for every element they encounter
		//also of interest is the fact that IE[6] doesn't apply style attribute properties
		//to a custom element's rendering, while all other browsers do; but I'm not going to allow for that
		//when returning property collections in browser mode ... maybe in the next version :-P
		//I mean ffs, I only noticed by accident; it's too late in the day to think about custom elements
		//except to the extent that I have done here, but that's only to ensure that the array indices
		//in the styleattrs array remain accurate with regard to matching indices in the "*" collection
		if(tagname == '*')
		{
			for(var i=0; i<thesenodes.length; i++)
			{
				if(thesenodes[i].nodeType != 1 || thesenodes[i].tagName.charAt(0) == '/')
				{
					thesenodes.splice(i--, 1);
				}
			}
		}
		
		//return the final array
		return thesenodes;
	}
	
	//late initialize method, used internally to initialize the script
	//if a public method is called without it having been pre-initialized
	function lateinit()
	{
		//if the script hasn't been initialized, do it now
		if(typeof THIS._cssRules == TYPE_UNDEFINED) 
		{ 
			THIS.init(); 
		}
	}
	
	//process a method's arguments array to create an indexed object
	//this makes it possible for users to omit any number of intermediate 
	//optional arguments, and have the onfinished callback be the last one
	function processArguments(argsary, keys)
	{
		//add onfinished to the keys
		//it's always the last argument to every public method
		//so we add it here to save listing it each time
		//and to maintain control over its existence  
		keys.push('onfinished');
		
		//create the empty indexed arguments object
		//then iterate through the specified keys array
		for(var args={}, i=0; i<keys.length; i++)
		{
			//as soon as we encounter a function within the arguments array
			//nullify all subsequent arguments then index the function to args.onfinished 
			//we put onfinished at the end to preserve the order of arguments
			//which is ultimately for consistency and therefore easier comprehension
			//nb. should we ever require any of the public methods to take a function argument
			//other than the callback, we will need to redesign this code to accomodate
			if(typeof argsary[i] == TYPE_FUNCTION)
			{
				for(var j=i; j<keys.length; j++)
				{
					args[keys[j]] = NULL_VALUE;
				}
				args.onfinished = argsary[i];
				
				//and we're done
				break;
			}
			//otherwise if this argument is undefined
			//create a null value at the corresponding index in the arguments object
			//all the other arg processing methods will then identify null 
			//the same as undefined, and so put the appropriate default value in its place 
			//(or throw an exception over it, if that's the appropriate response)
			else if(typeof argsary[i] == TYPE_UNDEFINED)
			{
				args[keys[i]] = NULL_VALUE;
			}
			//if the argument is defined then add it 
			//to the args object using the applicable index
			else
			{
				args[keys[i]] = argsary[i];
			}
		}
		
		//return the finished arguments object
		return args;
	}

	//process a method's element argument
	function processElementArgument(argelement, calledby)
	{
		//if the element argument is a string beginning with "#" 
		//then look for an element with that ID within the context document
		//if there isn't one then element will be set to null
		//which will make it fail the reference test that follows
		//nb. we use the leading # partly so we have future scope 
		//for accepting other kinds of reference string, 
		//and partly for consistency with CSS reference syntax,
		//but mostly just because I think it looks cooler :-D
		if(typeof argelement == TYPE_STRING && argelement.charAt(0) == '#')
		{
			argelement = page.getElementById(argelement.substr(1, argelement.length - 1));
		}
		
		//if element is undefined, null, or not an element, throw an error
		if(typeof argelement == TYPE_UNDEFINED  || argelement == NULL_VALUE 
			|| typeof argelement.nodeType == TYPE_UNDEFINED || argelement.nodeType != 1) 
		{ 
			throw(new Error(errorMessageNoElement.replace('%method', calledby))); 
		}
		
		//return the element reference
		return argelement;
	}
	
	//process a method's media argument
	function processMediaArgument(argmedia)
	{
		//if media is undefined, empty or null, default to "screen"
		if(typeof argmedia == TYPE_UNDEFINED || argmedia == '' || argmedia == NULL_VALUE) 
		{ 
			argmedia = MEDIA_SCREEN; 
		}
		
		//if argmedia is or contains the discreet value "*", this is the universal shortcut
		//meaning all media, including no media, which translates to "all,none"
		//so just set the argmedia value to that
		if(/(^|,)\*(,|$)/.test(argmedia)) 
		{ 
			argmedia = 'all,none'; 
		}
		
		//split the media argument into an array and trim the members
		argmedia = argmedia.split(',');
		for(var i=0; i<argmedia.length; i++) 
		{ 
			argmedia[i] = trim(argmedia[i]); 
			
			//if the value is "current" then set it to the current view media
			if(argmedia[i] == MEDIA_CURRENT) 
			{ 
				argmedia[i] = THIS._viewmedia; 
			}
		}
		
		//return the processed argument
		return argmedia;
	}
	
	//process a method's accept argument
	function processAcceptArgument(argaccept)
	{
		//if accept is undefined, empty, null or "null"
		//default to "*" which means "everything"
		if(typeof argaccept == TYPE_UNDEFINED 
			|| argaccept == '' || argaccept == NULL_VALUE || argaccept == 'null') 
		{ 
			argaccept = '*'; 
		}
		
		//then if accept is still a string, process it into an object 
		//so that we can easily test for values using typeof accept[key]
		//or if it's completely or contains "*" then make it just "*"
		//we have this condition for if it's already been processed 
		//because this can get called by recursive instances of getCSSRules
		//but we only actually need to process the argument 
		//on the first instance before it's already been processed
		else if(typeof argaccept == TYPE_STRING)
		{
			//trim the value
			argaccept = trim(argaccept);
			
			//if the value is "*" just leave it
			if(argaccept !== '*')
			{
				//if the string contains "*" among other delimited values, 
				//make it just "*" on its own
				//we test for delimiters so that, for example, 
				//"css*" is invalid rather than equating to "css,*"
				if(/(,\s*\*|\*\s*,)/.test(argaccept)) 
				{ 
					argaccept = '*'; 
				}
				
				//otherwise convert the string into an object
				else 
				{ 
					argaccept = lexiconize(argaccept, ','); 
				}
			}
		}
		
		//return the processed argument or existing object
		return argaccept;
	}
	
	//process a method's onfinished callback argument
	function processOnfinishedArgument(argonfinished)
	{
		//if onfinished is [undefined or null or] not a function, set it to null
		if(typeof argonfinished != TYPE_FUNCTION) 
		{ 
			argonfinished = NULL_VALUE; 
		}
		
		//return the processed argument
		return argonfinished;
	}
	
	//trim leading and trailing whitespace from a string
	function trim(str)
	{
		return str.replace(/^\s+|\s+$/g, '');
	}
		
	//check if an array contains a member
	//this can check simple arrays for whether they contain a member
	//(and in which case returns the member it found)
	//or it can check arrays of objects for whether they contain
	//a member with a property name matching the input key
	//(and in which case returns the member's parent object)
	//if there's no match it returns null
	function arrayContains(ary, member, key)
	{
		for(var i=0; i<ary.length; i++)
		{
			if(typeof key != TYPE_UNDEFINED && typeof ary[i] == TYPE_OBJECT)
			{
				if(ary[i][key] == member)
				{
					return ary[i];
				}
			}
			else if(ary[i] == member) 
			{
				return ary[i];
			}
		}
		return NULL_VALUE;
	}
	
	//convert a DOM NodeList to an array
	//cool name huh :-D
	function arrayifize(nodelist)
	{
		for(var ary=[], i=0; i<nodelist.length; i++)
		{
			ary.push(nodelist[i]);
		}
		return ary;
	}
	
	//convert a delimited string into a dictionary object of empty properties
	//so that we can easily test for a value with typeof obj[key]
	function lexiconize(str, delimiter)
	{
		//create the empty object
		var obj = {};
		
		//split the string by its delimiter
		str = str.split(delimiter);
		
		//if the final member contains media queries, split them off too
		//and add them to the array, deleting the whole final member itself
		//there's no need to look for the "only" token here because 
		//it will be gone from any media-types string before it gets here
		var tmp = str[str.length - 1];
		if(/[ \t]and/i.test(tmp))
		{
			tmp = tmp.split(/[ \t]and/i);
			str.splice(str.length-1, 1);			
			for(var i=0; i<tmp.length; i++)
			{
				str.push(tmp[i]);
			}
		}
		
		//iterate through the array and save each trimmed member to the object
		//we only need the object keys, so the values can be anything
		for(var i=0; i<str.length; i++)
		{
			obj[trim(str[i])] = '';
		}
		
		//return the object
		return obj;
	}

	//count the members of an object
	function howmany(obj)
	{
		var n = 0;
		for(var i in obj)
		{
			if(!obj.hasOwnProperty(i)) { continue; }
			
			n ++;
		}
		return n;
	}
	
	//qualify an HREF to form a complete URI
	function qualifyHREF(href, context)
	{
		//if the href is undefined return an empty string
		//the only time this is known to have an impact is in XHTML 
		//when an xml-stylesheet PI has its href pseudo-attribute 
		//in mixed or uppercase, resulting in no pseudoattrs.href property
		//and ultimately in an xml-stylesheet PI marked as "data is not CSS" 
		//(which matches what implementations actually do:
		// they can't load the stylesheet, because it has no known "href"!)
		//more generally, this will indirectly catch failure to retrieve a stylesheet's href
		//for any exceptional reason that hasn't been accounted for
		if(typeof href == TYPE_UNDEFINED) { return ''; }
		
		//extract the protocol, host and path
		//and create a location object with the data
		//nb. the first replacement here goes "/"+"/" instead of "//"
		//so that it's safe to do a global removal of //.*
		//when removing comments to minimize the script 
		var parts = context.replace('/'+'/', '/').split('/');
		var loc = {
			'protocol' : parts[0],
			'host' : parts[1]
			};
		parts.splice(0, 2);
		loc.pathname = '/' + parts.join('/');
		
		//build a base URI from the protocol plus host (which includes port if applicable)
		//nb. the "/"+"/" is for the same minimizing reason
		var uri = loc.protocol + '/'+'/' + loc.host;
		
		//if the input path is relative-from-here
		//just delete the ./ token to make it relative
		if(/^(\.\/)([^\/]?)/.test(href))
		{
			href = href.replace(/^(\.\/)([^\/]?)/, '$2');
		}
	
		//if the input href is already qualified, copy it unchanged
		if(/(^([a-z]+)\:\/\/)/.test(href))
		{
			uri = href;
		}
	
		//or if the input href begins with a leading slash, then it's base relative
		//so just add the input href to the base URI
		else if(href.substr(0, 1) == '/')
		{
			uri += href;
		}
	
		//or if it's an up-reference we need to compute the path
		else if(/^((\.\.\/)+)([^\/].*$)/.test(href))
		{
			//get the last part of the path, minus up-references
			var lastpath = href.match(/^((\.\.\/)+)([^\/].*$)/);
			lastpath = lastpath[lastpath.length - 1];
	
			//count the number of up-references
			var references = href.split('../').length - 1;
	
			//get the path parts and delete the last one (this page or directory)
			var parts = loc.pathname.split('/');
			parts = parts.splice(0, parts.length - 1);
	
			//for each of the up-references, delete the last part of the path
			for(var i=0; i<references; i++)
			{
				parts = parts.splice(0, parts.length - 1);
			}
	
			//now rebuild the path
			var path = '';
			for(i=0; i<parts.length; i++)
			{
				if(parts[i] != '')
				{
					path += '/' + parts[i];
				}
			}
			path += '/';
	
			//and add the last part of the path
			path += lastpath;
	
			//then add the path and input href to the base URI
			uri += path;
		}
	
		//otherwise it's a relative path,
		else
		{
			//calculate the path to this directory
			path = '';
			parts = loc.pathname.split('/');
			parts = parts.splice(0, parts.length - 1);
			for(var i=0; i<parts.length; i++)
			{
				if(parts[i] != '')
				{
					path += '/' + parts[i];
				}
			}
			path += '/';
	
			//then add the path and input href to the base URI
			uri += path + href;
		}
	
		//return the final uri
		return uri;
	}
	
	//load CSS or HTML data via XHR, either asynchronously or synchronously 
	//according to the value of the async flag argument
	//nb. we only use this method to retrieve data as text, never for active scripting,
	//because calling eval() on network data is just too dangerous
	function ajaxload(async, uri, oncomplete, onfail)
	{
		//try to create a request object
		//arranging the two conditions this way is for IE7/8's benefit
		//so that it works with any combination of ActiveX or Native XHR settings, 
		//as long as one or the other is enabled; but if both are enabled
		//it prefers ActiveX, which means it still works with local files
		//(Native XHR in IE7/8 is blocked and throws "access is denied",
		// but ActiveX is permitted if the user allows it [default is to prompt])
		var requestobject = NULL_VALUE;
		if(typeof window.ActiveXObject != TYPE_UNDEFINED)
		{
			try { requestobject = new ActiveXObject('Microsoft.XMLHTTP'); }
			catch(err) { requestobject = NULL_VALUE; }
		}
		if(requestobject == NULL_VALUE && typeof window.XMLHttpRequest != TYPE_UNDEFINED)
		{
			try { requestobject = new XMLHttpRequest(); }
			catch(err) { requestobject = NULL_VALUE; }
		}
		
		//if we failed to initiate a request then we can't do anything else
		//so we'll have to throw a fatal error and stop
		if(requestobject == NULL_VALUE) 
		{ 
			throw(new Error(FATAL_ERROR_NO_XHR)); 
		}

		//add a timestamp to the URI to prevent caching,
		//there are more subtle ways of trying to ensure a fresh response
		//but this approach has always proven the most reliable
		//we should give this a reasonably unique key
		//just in case the URI already has cgi parameters
		//#uri += (uri.indexOf('?') == -1 ? '?' : '&') + 'cssutilstamp=' + new Date().getTime();
		
		//open the request using the specified async flag 
		requestobject.open('GET', uri, async);
		
		//try to set a request header that defines a library user-agent string
		//this is something I like to do with programatic networking like ajax
		//so that site owners can identify such requests in their server logs
		//it's mostly for fun - like a little electronic hello :-)
		//and as a kind of side-door viral marketing! but it also provides
		//a means of filtering or otherwise handling such requests specially
		//ultimately though it's not essential, so silently fail [eg. if the method is unsupported]
		try { requestobject.setRequestHeader('User-Agent', LIBRARY_VERSION_STRING); }catch(err){}	
			
		//private response function
		function ajaxresponse(requestobject)
		{
			//if the status is okay, pass the trimmed response text to oncomplete
			//along with the Content-Type response header from this request
			//nb. we allow the status code 0 so that file:// addresses are supported
			//unfortunately though such requests also return an empty content-type
			//which means that we have to just accept all response text
			//without the ability to check whether its MIME type is text/css
			if(/(0|200|304)/.test(requestobject.status.toString()))
			{
				oncomplete(
					requestobject.responseText, 
					requestobject.getResponseHeader('Content-Type')
					);
			}

			//otherwise pass the trimmed status text to onfail
			else
			{
				onfail(trim(requestobject.statusText), requestobject.status);
			}
		}
		
		//if the async flag is true we're making an asynchronous request
		if(async == BOOLEAN_TRUE)
		{
			//create a readystatechange handler
			requestobject.onreadystatechange = function()
			{
				//when the request completes
				if(requestobject.readyState == 4)
				{
					//***DEV SEMI-RANDOMIZED LATENCY
					//setTimeout(function() { 
					
					//call the response function with the request object
					ajaxresponse(requestobject);
					
					//***DEV SEMI-RANDOMIZED LATENCY
					//}, (33 * Math.random()));
				}
			};

			//make the request, with exception handling 
			//to catch failures such as no network connection
			try 
			{ 
				requestobject.send(NULL_VALUE); 
			}

			//if just that individual request failed
			//pass a network or security error message to onfail 
			//we have to be ambiguous here because this exception handler alone
			//is not enough to establish whether the request failed
			//(eg. no internet connection), or whether we tried to make a request 
			//that violated the same-origin policy; although most of those 
			//are caught by other exception handlers, it can still happen here too
			catch(err)
			{
				onfail(ERROR_NETWORK_OR_SECURITY);
			}
		}
		
		//otherwise it's false so we're making a synchronous request
		else
		{
			//we have to make sure that the response callback is outside the try..catch construct
			//otherwise any errors within it, or anything it calls, will execute the catch block
			//## so any coding errors made by the user inside their init callback will execute it ##
			//which can lead to any genuine errors being obscured by unrelated errors fired from here
			//(errors which only happen because code is being forced to execute out of context)
			//so we need to make sure that the catch block doesn't call anything else 
			//so that if it is called out of context, nothing else happens as a result
			//we only need to do this for the synchronous case, 
			//because asynchronous calls don't display the same behavior
			//(not 100% sure why, but it's undoubtedly something to do with execution scope)
			var success;
			
			//make the request inside the try construct
			//and set the success flag to true
			try
			{
				requestobject.send(NULL_VALUE);

				success = BOOLEAN_TRUE;
			}
			//if we have failure set the success flag to false
			catch(err) 
			{ 
				success = BOOLEAN_FALSE; 
			}
			
			//if success is true call the response function with the request object
			if(success === BOOLEAN_TRUE)
			{
				ajaxresponse(requestobject);
			}
			
			//otherwise pass the network or security error message to onfail 
			else
			{
				onfail(ERROR_NETWORK_OR_SECURITY);
			}
		}
	}
	

}).apply(CSSUtilities);
</script>
    <script>(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * This component is responsible for highlighting the
 * components inside the application and communicating with the external 
 * world by means of the `window.postMessage` and 
 * `window.addEventListener('message')` methods.
 *
 * It has and implementation of a request-response model through that channel, 
 * for more information, see handleFrameRequestMessage
 * 
 * @author Simon Fan, Pat Jenny, Lu Heuko
 */

/**
 * Constants used throughout the component code.
 * @type {Object}
 */
var CONSTANTS = require('./scripts/constants');

/**
 * The class that defines a scope for the highlighters
 * @type {Function}
 */
var HighlighterScope = require('./scripts/classes/highlighter-scope');

/**
 * Behaviors
 */
var FrameMessagingBehavior = require('./scripts/behaviors/frame-messaging');
var AnalysisBehavior       = require('./scripts/behaviors/analysis');
var CanvasBehavior         = require('./scripts/behaviors/canvas');

/**
 * Register the carbo-inspector element
 */
Polymer({
    is: 'carbo-inspector',

    behaviors: [FrameMessagingBehavior, AnalysisBehavior, CanvasBehavior],

    /**
     * Method called whenever the component is ready
     */
    ready: function () {
        /**
         * Array to store the highlighters created
         * for the inspector instance.
         * @type {Array}
         */
        this[CONSTANTS.highlightersNs] = [];
    },

    /**
     * Creates an instance of carbo-highlighter
     * given the options.
     * @param  {Object} options Passed to carbo-highlighter. Also will be
     *                          set on the highlighter data object.
     * @return {CarboHighlighter}         [description]
     */
    createHighlighter: function (options) {

        // Highlighter object
        var _highlighter = new HighlighterScope(options, this);

        // Using this mechanism of creation because Polymer
        // still does not support dinamic data-binding
        // We are using dom-repeat to create
        // the _highlighter instances.
        this.push(CONSTANTS.highlightersNs, _highlighter);

        // Do not forget to flush modifications
        // so that we can safely retrieve
        // the element immediately.
        Polymer.dom.flush();

        // Select the highlighter element just created and
        // save reference at the _highlighter data object
        _highlighter.element = this.$$('#' + _highlighter.id);

        // Return the virtual highlighter object
        return _highlighter;
    },

    /**
     * Retrieves an highlighter object
     * @param  {String} highlighterId 
     *     Identification of the highlighter
     * @return {HighlighterScope}
     *     Representation of the highlighter object
     */
    getHighlighter: function (highlighterId) {
        return _.find(this[CONSTANTS.highlightersNs], function (hlt) {
            return hlt.id === highlighterId;
        });
    },
    
    /**
     * Scrolls the window
     * @param  {Number} deltaX
     * @param  {Number} deltaY
     */
    scrollBy: function (deltaX, deltaY) {
        // console.log('scroll x: %s, y: %s', deltaX, deltaY);
        window.scrollBy(deltaX, deltaY);
    },
});
},{"./scripts/behaviors/analysis":3,"./scripts/behaviors/canvas":4,"./scripts/behaviors/frame-messaging":5,"./scripts/classes/highlighter-scope":7,"./scripts/constants":8}],2:[function(require,module,exports){
/**
 * Helper methods for manipulating DOMNodes
 */

/**
 * Retrieves the computed style of an given element
 * @param  {DOMNode} element The element from which to read computedSytles
 * @return {Object}          Object with the computed styles
 */
exports.getComputedStyle = function (element) {

    if (!element) {
        throw new Error('No element for getComputedStyle(element)');
    }

    var cs = {};

    // Get the computed cs of the element
    var _cs = window.getComputedStyle(element);

    for (var i = _cs.length - 1; i >=0; i--) {
        var prop = _cs[i];

        cs[prop] = _cs.getPropertyValue(prop);
    }

    return cs;
};

/**
 * Retrieves the attributes of a given element
 * @param  {DOMNode} element The element from which to read attributes
 * @return {Object}          Object with all attributes
 */
exports.getAttributes = function (element) {

    if (!element) {
        throw new Error('No element for getAttributes(element)');
    }

    // Object on which to store attributes
    var attributes = {};

    var _attrs = element.attributes;

    for (var i = _attrs.length - 1; i >= 0; i--) {
        attributes[_attrs[i].name] = _attrs[i].value;
    }

    return attributes;
};
},{}],3:[function(require,module,exports){
var DOMHelpers = require('../aux/dom');

exports.getElementAtPoint = function (point) {

}
},{"../aux/dom":2}],4:[function(require,module,exports){
/**
 * Implements behaviors only valid for canvas usage.
 */

exports.attached = function () {


    this._canvas = {

        highlighters: {
            hover: this.createHighlighter({
                surfaceStyle: {
                    border: '3px dashed green'
                }
            }),

            focus: this.createHighlighter({
                surfaceStyle: {
                    border: '3px solid green'
                }
            }),

            loading: this.createHighlighter({
                surfaceStyle: {
                    backgroundColor: 'green',
                    opacity: '0.3',
                }
            }),
        }
    };
};

/**
 * Highlights the element at a given point
 * @param {Object{ x: Number, y: Number}} 
 *         point The point at which the element to be highlighted is
 * @param {Boolean} force
 */
exports.highlightElementAtPoint = function (highlighter, point, force) {
    // get hovered component (Element under that position)
    var element = document.elementFromPoint(point.x, point.y);

    var hlt = this._canvas.highlighters[highlighter];

    hlt.highlight(element);
};

/**
 * Unhighlights
 */
exports.unHighlight = function (highlighter) {
    var hlt = this._canvas.highlighters[highlighter];

    hlt.hide();
};

/**
 * Retrieves information about the active element.
 * @return {{tagName: String, attributes: Object, computedStyle: Object }Object} 
 *         Data on the current active element.
 */
exports.getActiveElementData = function (highlighter) {

    var hlt = this._canvas.highlighters[highlighter];

    return hlt.getTargetData();
};


exports.areFocusAndHoverTogether = function () {

    var focus = this._canvas.highlighters.focus;
    var hover = this._canvas.highlighters.hover;

    return focus.target === hover.target;
};

exports.activateLoading = function () {

    var hlt = this._canvas.highlighters.focus;

    this.$.loading.highlight(hlt.target);
};

exports.deactivateLoading = function () {
    this.$.loading.hide();
};

var WHITELISTED_HIGHLIGHTER_OPERATIONS = {
    getCSSRules: true,
    getCSSSelectors: true,
    getCSSProperties: true,
    getCSSSelectorSpecificity: true
};

/**
 * Executes an operation on a given highlighter
 * @param  {String} highlighterId 
 *     Identifier of the highlighter onto which the operation should be
 *     executed
 * @param  {String} operation
 *     Name of the operation to be executed
 * @param  {Array|*} args
 *     Set of arguments to be passed to the operation
 * @return {*}
 *     Results of the operation. Whatever the operation returns.
 */
exports.executeHighlighterOperation = function (highlighterId, operation, args) {

    // retrieve the highlighter object
    var highlighter = this.getHighlighter(highlighterId) || this._canvas.highlighters.focus;

    if (WHITELISTED_HIGHLIGHTER_OPERATIONS[operation]) {
        return highlighter[operation].apply(highlighter, args);
    } else {
        throw new Error('Too bad: highlighter operation `' + operation + '` not whitelisted. :(')
    }
};
},{}],5:[function(require,module,exports){
/**
 * Enables messaging between frames
 */

var CONSTANTS = require('../constants');

/**
 * Method called whenever the component is ready
 */
exports.ready = function () {
    // Listen to `message` events on the window object.
    // The window is the object that contains the whole application,
    // in the case of the edited application (inside which is the inspector component)
    // it is the `iframe`. 
    // 
    // Only the window receives messages.
    window.addEventListener('message', this.handleFrameRequestMessage.bind(this), false);
};

/**
 * Handles messages from the parent frame.
 * @param  {Event} event the event object
 */
exports.handleFrameRequestMessage = function (event) {
    // método JSON.parse() converte string para JSON
    var request = JSON.parse(event.data);

    // Check if the operationName is whitelisted
    // Not all methods on the inspector object should be
    // available for outside use for security reasons.
    // Thus we should whitelist the available methods
    var operationWhitelisted = CONSTANTS.operationWhitelist[request.operation]; 

    if (operationWhitelisted) {
        // Execute the operation and store the result
        var res = this[request.operation].apply(this, request.args);

        // If the result is a promise, wait for the promise to be 
        // done before returning results
        Q.when(res)
            .then(function (finalRes) {

                // Send message to parent frame passing the request.id
                // so that the parent may resolve to the correct inquiry.
                parent.postMessage(JSON.stringify({
                    id: request.id,

                    // If there is a method to convert the object into 
                    // plain JSON object, do so.
                    res: (finalRes !== undefined && finalRes.toPlainObject) ? finalRes.toPlainObject() : finalRes
                }), '*');

            }.bind(this))
            // terminate promise chain
            .done();

    } else {
        throw new Error('Operation %s is not available at inspector', request.operation);
    }
};
},{"../constants":8}],6:[function(require,module,exports){
/**
 * @class CSSInspector
 *
 * Defines a class for inspecting css rules and stylesheets
 * and their effects on target elements.
 *
 * For the time being, does not perform any intelligence,
 * it delegates to CSSUtilities (by brothercake).
 * 
 * For docs on CSSUtilities:
 * // http://www.brothercake.com/site/resources/scripts/cssutilities/functions
 */

/**
 * Class that proxies methods to CSSUtilities
 * @param {Node} element The element the inspector should work upon
 */
function CSSInspector(defaultOptions, element) {

    // Save the default options
    this.defaultOptions = defaultOptions;

    this.setTarget(element);
}

/**
 * Sets the target element
 * @param {[type]} element [description]
 */
CSSInspector.prototype.setTarget = function (element) {
    this.target = element;
};

/**
 * Default options for `getCSSRules`
 * @type {Object}
 */
var GET_CSS_RULES_DEFAULTS = {
    media: 'screen',
    properties: ['properties', 'selector', 'css'],
    altstates: true,
};

/**
 * Retrieves the rules that apply to the element
 * @param  {[type]} options [description]
 * @return {Promise -> Array}         [description]
 */
CSSInspector.prototype.getCSSRules = function (options) {
    if (!this.target) {
        throw new Error('No target for `getCSSRules`');
    }
    
    // Default setting
    options = _.assign({}, GET_CSS_RULES_DEFAULTS, options);
    // create a defer object
    var defer = Q.defer();
    
    // properties option must be String
    var properties = _.isArray(options.properties) ? 
        options.properties.join(',') : 
        options.properties;

    try {
        // CSSUtilities.getCSSRules(element [, media] [, properties] [, altstates] [, oncomplete])
        CSSUtilities.getCSSRules(
            this.target, 
            options.media, 
            properties,
            options.altstates,
            function (rules) {
                defer.resolve(rules.map(function (r) {
                    return {
                        selector: r.selector,
                        css: r.css,
                        properties: r.properties,
                    };
                }));
            }
        );
    } catch (e) {
        defer.reject(e);
    }

    // return the promise
    return defer.promise;
};

/**
 * Default options for `getCSSProperties`
 * @type {Object}
 */
var GET_CSS_PROPERTIES_DEFAULTS = {
    media: 'screen',
};

/**
 * Retrieves css properties related to the target element
 * @param  {Object} options [description]
 * @return {Promise -> Array}
 */
CSSInspector.prototype.getCSSProperties = function (options) {
    if (!this.target) {
        throw new Error('No target for `getCSSProperties`');
    }

    // Default setting
    options = _.assign({}, GET_CSS_PROPERTIES_DEFAULTS, options);
    // create a defer object
    var defer = Q.defer();

    try {
        // CSSUtilities.getCSSProperties(element [, media] [, oncomplete])
        CSSUtilities.getCSSProperties(
            this.target, 
            options.media, 
            defer.resolve
        );
    } catch (e) {
        defer.reject(e);
    }

    // return the promise
    return defer.promise;
};

/**
 * Default options for getCSSSelectors
 * @type {Object}
 */
var GET_CSS_SELECTORS_DEFAULTS = {
    media: 'screen',
    directonly: true,
};

/**
 * Retrieves css selectors that apply to the target element.
 * @param  {Object} options 
 * @return {Promise -> Array}
 *     Taken from CSSUtilities docs
 *     "The method returns an array of zero or more selectors,
 *     each of which is a String CSS selector,
 *     trimmed of leading or trailing whitespace."
 */
CSSInspector.prototype.getCSSSelectors = function (options) {
    if (!this.target) {
        throw new Error('[CSSInspector] No target for `getCSSSelectors`');
    }

    // Default setting
    options = _.assign({}, GET_CSS_SELECTORS_DEFAULTS, options);

    var defer = Q.defer();
    // CSSUtilities.getCSSSelectors(element [, media] [, directonly] [, oncomplete])
    
    // TODO: study error handling with CSSUtilities
    // Its asynchronous api should not be dealt with try-catch
    // but instead some way of error handling on the callback.
    // But the correct error handling mode was not found until now 
    // (just starting experiment)
    try {
        CSSUtilities.getCSSSelectors(
            this.target, 
            options.media, 
            options.directonly,
            function (selectors) {
                defer.resolve(selectors);
            }
        );
    } catch (e) {
        defer.reject(e);
    }

    return defer.promise;
};


/**
 * Retrieves selector specificity for a given element
 * @param  {[type]} options [description]
 * @return {[type]}         [description]
 */
CSSInspector.prototype.getCSSSelectorSpecificity = function (options) {
    if (!this.target) {
        throw new Error('[CSSInspector] No target for `getCSSSelectorSpecificity`');
    }
    // CSSUtilities.getCSSSelectorSpecificity(selector [, element] [, oncomplete])
};

/**
 * Static methods
 */

CSSInspector.getCSSSelectorSpecificity = function (options) {
    // CSSUtilities.getCSSSelectorSpecificity(selector [, element] [, oncomplete])
};
CSSInspector.getCSSStyleSheetRules = function (options) {
    // CSSUtilities.getCSSStyleSheetRules([media] [, accept] [, ssid] [, oncomplete])
};
CSSInspector.getCSSStyleSheets = function () {
    // CSSUtilities.getCSSStyleSheets([oncomplete])
};

/**
 * Initializes CSSUtilities
 * @return {[type]} [description]
 */
function initializeCSSUtilities() {
    // CSSUtilities is available as a global
    // as it was imported via `script` tag
    
    // set config and initialize
    // Use author mode because we need to access the actual 
    // stylesheets.
    // 
    // This incurs in one extra ajax get request 
    // for each stylesheet in the inspected application.
    // 
    // Also, some methods will run in asynchronous mode, 
    // with callbacks.
    // 
    // docs:
    // http://www.brothercake.com/site/resources/scripts/cssutilities/config/#config-mode
    CSSUtilities.define('mode', 'browser');
    CSSUtilities.define('async', true);
    // Do not take into account inline styles
    CSSUtilities.define('attributes', false);
    CSSUtilities.init();
}

// invoke CSSUtilities initialization immediately
initializeCSSUtilities();

// export
module.exports = CSSInspector;
},{}],7:[function(require,module,exports){
/**
 * Class that is responsible for encapsulating scope 
 * for each of the highlighter elements within.
 */

var CONSTANTS      = require('../constants');
var highlightersNs = CONSTANTS.highlightersNs;

var DOMHelpers = require('../aux/dom');


// Load internal dependencies
var CSSInspector = require('./css-inspector');

/**
 * Class that represents the carbo-highlighter element
 * virtually.
 * @param {Object} [data] Data to be set on the scope
 * @param {<carbo-inspector>} [inspector] The inspector instance
 *                                        the highlighter is owned by.
 */
function HighlighterScope(data, inspector) {

    this.id = _.uniqueId('highlighter_');

    // keep reference to the inspector instance
    this.inspector = inspector;

    // Get all data
    _.assign(this, data);

    // instantiate a CSSInspector
    this._cssInspector = new CSSInspector();
}

/**
 * Proxies <carbo-highlighter>.highlight method
 * @param  {Node} element Node to be highlighted
 * @param  {Object} options 
 */
HighlighterScope.prototype.highlight = function (element, options) {

    if (!this.element) {
        throw new Error('No element for HighlighterScope');
    }

    this.set('elementLabel', element.tagName);

    this.element.highlight(element, options);
};

/**
 * Proxies the <carbo-highlighter>.hide method
 */
HighlighterScope.prototype.hide = function () {
    if (!this.element) {
        throw new Error('No element for HighlighterScope');
    }

    this.element.hide();
};

/**
 * Helper method to set data using polymer stuff
 */
HighlighterScope.prototype.set = function (property, value) {

    var path = highlightersNs + '.' + this.index + '.' + property;

    this.inspector.set(path, value);
};

/**
 * Retrieves data about the elemtn
 * @return {Object} [description]
 */
HighlighterScope.prototype.getTargetData = function () {

    var target = this.element.target;
    var data;

    if (target) {

        var boundingRect = target.getBoundingClientRect();

        data = {
            tagName: target.tagName,
            attributes: DOMHelpers.getAttributes(target),
            computedStyle: DOMHelpers.getComputedStyle(target),
            rect: {
                top: boundingRect.top,
                left: boundingRect.left,
                width: boundingRect.width,
                height: boundingRect.height,
            },
        };
    }

    return data;
};

/**
 * Converts the scope data into a plain object ready for 
 * JSON stringification
 * @return {Object}
 */
HighlighterScope.prototype.toPlainObject = function () {

    var obj = {
        id: this.id
    };
    
    return obj;
};

/**
 * Define the index property
 * which will just point to the index at which the highlighter scope
 * is stored at the inspector object.
 */
Object.defineProperty(HighlighterScope.prototype, 'index', {
    get: function () {

        var _highlighters = this.inspector[CONSTANTS.highlightersNs]; 

        return _.indexOf(_highlighters, this);
    },
});



/**
 * CSSInspector proxy methods
 */
var CSS_INSPECTOR_PROXY_METHODS = [
    'getCSSRules',
    'getCSSSelectors',
    'getCSSProperties',
    'getCSSSelectorSpecificity',
];

CSS_INSPECTOR_PROXY_METHODS.forEach(function (methodName) {
    HighlighterScope.prototype[methodName] = function (options) {
        // set the target of the _cssInspector
        this._cssInspector.setTarget(this.element.target);
        return this._cssInspector[methodName](options);
    };
});

module.exports = HighlighterScope;
},{"../aux/dom":2,"../constants":8,"./css-inspector":6}],8:[function(require,module,exports){
/**
 * List of operations that can be called via window.postMessage
 * from the outer world.
 * @type {Object}
 */
exports.operationWhitelist = {
    'highlightElementAtPoint': true,
    'unHighlight': true,
    'getActiveElementData': true,
    'scrollBy': true,
    'areFocusAndHoverTogether': true,
    'activateLoading': true,
    'deactivateLoading': true,
    'executeHighlighterOperation': true
};

/**
 * Name of the property at which highlighers will be stored.
 * @type {String}
 */
exports.highlightersNs = '_highlighters';

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvY2FyYm8taW5zcGVjdG9yLmpzIiwic3JjL3NjcmlwdHMvYXV4L2RvbS5qcyIsInNyYy9zY3JpcHRzL2JlaGF2aW9ycy9hbmFseXNpcy5qcyIsInNyYy9zY3JpcHRzL2JlaGF2aW9ycy9jYW52YXMuanMiLCJzcmMvc2NyaXB0cy9iZWhhdmlvcnMvZnJhbWUtbWVzc2FnaW5nLmpzIiwic3JjL3NjcmlwdHMvY2xhc3Nlcy9jc3MtaW5zcGVjdG9yLmpzIiwic3JjL3NjcmlwdHMvY2xhc3Nlcy9oaWdobGlnaHRlci1zY29wZS5qcyIsInNyYy9zY3JpcHRzL2NvbnN0YW50cy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogVGhpcyBjb21wb25lbnQgaXMgcmVzcG9uc2libGUgZm9yIGhpZ2hsaWdodGluZyB0aGVcbiAqIGNvbXBvbmVudHMgaW5zaWRlIHRoZSBhcHBsaWNhdGlvbiBhbmQgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBleHRlcm5hbCBcbiAqIHdvcmxkIGJ5IG1lYW5zIG9mIHRoZSBgd2luZG93LnBvc3RNZXNzYWdlYCBhbmQgXG4gKiBgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnKWAgbWV0aG9kcy5cbiAqXG4gKiBJdCBoYXMgYW5kIGltcGxlbWVudGF0aW9uIG9mIGEgcmVxdWVzdC1yZXNwb25zZSBtb2RlbCB0aHJvdWdoIHRoYXQgY2hhbm5lbCwgXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIGhhbmRsZUZyYW1lUmVxdWVzdE1lc3NhZ2VcbiAqIFxuICogQGF1dGhvciBTaW1vbiBGYW4sIFBhdCBKZW5ueSwgTHUgSGV1a29cbiAqL1xuXG4vKipcbiAqIENvbnN0YW50cyB1c2VkIHRocm91Z2hvdXQgdGhlIGNvbXBvbmVudCBjb2RlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIENPTlNUQU5UUyA9IHJlcXVpcmUoJy4vc2NyaXB0cy9jb25zdGFudHMnKTtcblxuLyoqXG4gKiBUaGUgY2xhc3MgdGhhdCBkZWZpbmVzIGEgc2NvcGUgZm9yIHRoZSBoaWdobGlnaHRlcnNcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIEhpZ2hsaWdodGVyU2NvcGUgPSByZXF1aXJlKCcuL3NjcmlwdHMvY2xhc3Nlcy9oaWdobGlnaHRlci1zY29wZScpO1xuXG4vKipcbiAqIEJlaGF2aW9yc1xuICovXG52YXIgRnJhbWVNZXNzYWdpbmdCZWhhdmlvciA9IHJlcXVpcmUoJy4vc2NyaXB0cy9iZWhhdmlvcnMvZnJhbWUtbWVzc2FnaW5nJyk7XG52YXIgQW5hbHlzaXNCZWhhdmlvciAgICAgICA9IHJlcXVpcmUoJy4vc2NyaXB0cy9iZWhhdmlvcnMvYW5hbHlzaXMnKTtcbnZhciBDYW52YXNCZWhhdmlvciAgICAgICAgID0gcmVxdWlyZSgnLi9zY3JpcHRzL2JlaGF2aW9ycy9jYW52YXMnKTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGUgY2FyYm8taW5zcGVjdG9yIGVsZW1lbnRcbiAqL1xuUG9seW1lcih7XG4gICAgaXM6ICdjYXJiby1pbnNwZWN0b3InLFxuXG4gICAgYmVoYXZpb3JzOiBbRnJhbWVNZXNzYWdpbmdCZWhhdmlvciwgQW5hbHlzaXNCZWhhdmlvciwgQ2FudmFzQmVoYXZpb3JdLFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGNhbGxlZCB3aGVuZXZlciB0aGUgY29tcG9uZW50IGlzIHJlYWR5XG4gICAgICovXG4gICAgcmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFycmF5IHRvIHN0b3JlIHRoZSBoaWdobGlnaHRlcnMgY3JlYXRlZFxuICAgICAgICAgKiBmb3IgdGhlIGluc3BlY3RvciBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpc1tDT05TVEFOVFMuaGlnaGxpZ2h0ZXJzTnNdID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgY2FyYm8taGlnaGxpZ2h0ZXJcbiAgICAgKiBnaXZlbiB0aGUgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgUGFzc2VkIHRvIGNhcmJvLWhpZ2hsaWdodGVyLiBBbHNvIHdpbGwgYmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0IG9uIHRoZSBoaWdobGlnaHRlciBkYXRhIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtDYXJib0hpZ2hsaWdodGVyfSAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBjcmVhdGVIaWdobGlnaHRlcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBIaWdobGlnaHRlciBvYmplY3RcbiAgICAgICAgdmFyIF9oaWdobGlnaHRlciA9IG5ldyBIaWdobGlnaHRlclNjb3BlKG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgICAgIC8vIFVzaW5nIHRoaXMgbWVjaGFuaXNtIG9mIGNyZWF0aW9uIGJlY2F1c2UgUG9seW1lclxuICAgICAgICAvLyBzdGlsbCBkb2VzIG5vdCBzdXBwb3J0IGRpbmFtaWMgZGF0YS1iaW5kaW5nXG4gICAgICAgIC8vIFdlIGFyZSB1c2luZyBkb20tcmVwZWF0IHRvIGNyZWF0ZVxuICAgICAgICAvLyB0aGUgX2hpZ2hsaWdodGVyIGluc3RhbmNlcy5cbiAgICAgICAgdGhpcy5wdXNoKENPTlNUQU5UUy5oaWdobGlnaHRlcnNOcywgX2hpZ2hsaWdodGVyKTtcblxuICAgICAgICAvLyBEbyBub3QgZm9yZ2V0IHRvIGZsdXNoIG1vZGlmaWNhdGlvbnNcbiAgICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gc2FmZWx5IHJldHJpZXZlXG4gICAgICAgIC8vIHRoZSBlbGVtZW50IGltbWVkaWF0ZWx5LlxuICAgICAgICBQb2x5bWVyLmRvbS5mbHVzaCgpO1xuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgaGlnaGxpZ2h0ZXIgZWxlbWVudCBqdXN0IGNyZWF0ZWQgYW5kXG4gICAgICAgIC8vIHNhdmUgcmVmZXJlbmNlIGF0IHRoZSBfaGlnaGxpZ2h0ZXIgZGF0YSBvYmplY3RcbiAgICAgICAgX2hpZ2hsaWdodGVyLmVsZW1lbnQgPSB0aGlzLiQkKCcjJyArIF9oaWdobGlnaHRlci5pZCk7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSB2aXJ0dWFsIGhpZ2hsaWdodGVyIG9iamVjdFxuICAgICAgICByZXR1cm4gX2hpZ2hsaWdodGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gaGlnaGxpZ2h0ZXIgb2JqZWN0XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBoaWdobGlnaHRlcklkIFxuICAgICAqICAgICBJZGVudGlmaWNhdGlvbiBvZiB0aGUgaGlnaGxpZ2h0ZXJcbiAgICAgKiBAcmV0dXJuIHtIaWdobGlnaHRlclNjb3BlfVxuICAgICAqICAgICBSZXByZXNlbnRhdGlvbiBvZiB0aGUgaGlnaGxpZ2h0ZXIgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0SGlnaGxpZ2h0ZXI6IGZ1bmN0aW9uIChoaWdobGlnaHRlcklkKSB7XG4gICAgICAgIHJldHVybiBfLmZpbmQodGhpc1tDT05TVEFOVFMuaGlnaGxpZ2h0ZXJzTnNdLCBmdW5jdGlvbiAoaGx0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGx0LmlkID09PSBoaWdobGlnaHRlcklkO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgdGhlIHdpbmRvd1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gZGVsdGFYXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBkZWx0YVlcbiAgICAgKi9cbiAgICBzY3JvbGxCeTogZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzY3JvbGwgeDogJXMsIHk6ICVzJywgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB3aW5kb3cuc2Nyb2xsQnkoZGVsdGFYLCBkZWx0YVkpO1xuICAgIH0sXG59KTsiLCIvKipcbiAqIEhlbHBlciBtZXRob2RzIGZvciBtYW5pcHVsYXRpbmcgRE9NTm9kZXNcbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgYW4gZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtICB7RE9NTm9kZX0gZWxlbWVudCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQgY29tcHV0ZWRTeXRsZXNcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgT2JqZWN0IHdpdGggdGhlIGNvbXB1dGVkIHN0eWxlc1xuICovXG5leHBvcnRzLmdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBmb3IgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KScpO1xuICAgIH1cblxuICAgIHZhciBjcyA9IHt9O1xuXG4gICAgLy8gR2V0IHRoZSBjb21wdXRlZCBjcyBvZiB0aGUgZWxlbWVudFxuICAgIHZhciBfY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGZvciAodmFyIGkgPSBfY3MubGVuZ3RoIC0gMTsgaSA+PTA7IGktLSkge1xuICAgICAgICB2YXIgcHJvcCA9IF9jc1tpXTtcblxuICAgICAgICBjc1twcm9wXSA9IF9jcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuICAgIH1cblxuICAgIHJldHVybiBjcztcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBhdHRyaWJ1dGVzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtICB7RE9NTm9kZX0gZWxlbWVudCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQgYXR0cmlidXRlc1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICBPYmplY3Qgd2l0aCBhbGwgYXR0cmlidXRlc1xuICovXG5leHBvcnRzLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBmb3IgZ2V0QXR0cmlidXRlcyhlbGVtZW50KScpO1xuICAgIH1cblxuICAgIC8vIE9iamVjdCBvbiB3aGljaCB0byBzdG9yZSBhdHRyaWJ1dGVzXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHZhciBfYXR0cnMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKHZhciBpID0gX2F0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbX2F0dHJzW2ldLm5hbWVdID0gX2F0dHJzW2ldLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xufTsiLCJ2YXIgRE9NSGVscGVycyA9IHJlcXVpcmUoJy4uL2F1eC9kb20nKTtcblxuZXhwb3J0cy5nZXRFbGVtZW50QXRQb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuXG59IiwiLyoqXG4gKiBJbXBsZW1lbnRzIGJlaGF2aW9ycyBvbmx5IHZhbGlkIGZvciBjYW52YXMgdXNhZ2UuXG4gKi9cblxuZXhwb3J0cy5hdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcblxuXG4gICAgdGhpcy5fY2FudmFzID0ge1xuXG4gICAgICAgIGhpZ2hsaWdodGVyczoge1xuICAgICAgICAgICAgaG92ZXI6IHRoaXMuY3JlYXRlSGlnaGxpZ2h0ZXIoe1xuICAgICAgICAgICAgICAgIHN1cmZhY2VTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXI6ICczcHggZGFzaGVkIGdyZWVuJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICBmb2N1czogdGhpcy5jcmVhdGVIaWdobGlnaHRlcih7XG4gICAgICAgICAgICAgICAgc3VyZmFjZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcjogJzNweCBzb2xpZCBncmVlbidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgbG9hZGluZzogdGhpcy5jcmVhdGVIaWdobGlnaHRlcih7XG4gICAgICAgICAgICAgICAgc3VyZmFjZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogJzAuMycsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBIaWdobGlnaHRzIHRoZSBlbGVtZW50IGF0IGEgZ2l2ZW4gcG9pbnRcbiAqIEBwYXJhbSB7T2JqZWN0eyB4OiBOdW1iZXIsIHk6IE51bWJlcn19IFxuICogICAgICAgICBwb2ludCBUaGUgcG9pbnQgYXQgd2hpY2ggdGhlIGVsZW1lbnQgdG8gYmUgaGlnaGxpZ2h0ZWQgaXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VcbiAqL1xuZXhwb3J0cy5oaWdobGlnaHRFbGVtZW50QXRQb2ludCA9IGZ1bmN0aW9uIChoaWdobGlnaHRlciwgcG9pbnQsIGZvcmNlKSB7XG4gICAgLy8gZ2V0IGhvdmVyZWQgY29tcG9uZW50IChFbGVtZW50IHVuZGVyIHRoYXQgcG9zaXRpb24pXG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuXG4gICAgdmFyIGhsdCA9IHRoaXMuX2NhbnZhcy5oaWdobGlnaHRlcnNbaGlnaGxpZ2h0ZXJdO1xuXG4gICAgaGx0LmhpZ2hsaWdodChlbGVtZW50KTtcbn07XG5cbi8qKlxuICogVW5oaWdobGlnaHRzXG4gKi9cbmV4cG9ydHMudW5IaWdobGlnaHQgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0ZXIpIHtcbiAgICB2YXIgaGx0ID0gdGhpcy5fY2FudmFzLmhpZ2hsaWdodGVyc1toaWdobGlnaHRlcl07XG5cbiAgICBobHQuaGlkZSgpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGFjdGl2ZSBlbGVtZW50LlxuICogQHJldHVybiB7e3RhZ05hbWU6IFN0cmluZywgYXR0cmlidXRlczogT2JqZWN0LCBjb21wdXRlZFN0eWxlOiBPYmplY3QgfU9iamVjdH0gXG4gKiAgICAgICAgIERhdGEgb24gdGhlIGN1cnJlbnQgYWN0aXZlIGVsZW1lbnQuXG4gKi9cbmV4cG9ydHMuZ2V0QWN0aXZlRWxlbWVudERhdGEgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0ZXIpIHtcblxuICAgIHZhciBobHQgPSB0aGlzLl9jYW52YXMuaGlnaGxpZ2h0ZXJzW2hpZ2hsaWdodGVyXTtcblxuICAgIHJldHVybiBobHQuZ2V0VGFyZ2V0RGF0YSgpO1xufTtcblxuXG5leHBvcnRzLmFyZUZvY3VzQW5kSG92ZXJUb2dldGhlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBmb2N1cyA9IHRoaXMuX2NhbnZhcy5oaWdobGlnaHRlcnMuZm9jdXM7XG4gICAgdmFyIGhvdmVyID0gdGhpcy5fY2FudmFzLmhpZ2hsaWdodGVycy5ob3ZlcjtcblxuICAgIHJldHVybiBmb2N1cy50YXJnZXQgPT09IGhvdmVyLnRhcmdldDtcbn07XG5cbmV4cG9ydHMuYWN0aXZhdGVMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGhsdCA9IHRoaXMuX2NhbnZhcy5oaWdobGlnaHRlcnMuZm9jdXM7XG5cbiAgICB0aGlzLiQubG9hZGluZy5oaWdobGlnaHQoaGx0LnRhcmdldCk7XG59O1xuXG5leHBvcnRzLmRlYWN0aXZhdGVMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJC5sb2FkaW5nLmhpZGUoKTtcbn07XG5cbnZhciBXSElURUxJU1RFRF9ISUdITElHSFRFUl9PUEVSQVRJT05TID0ge1xuICAgIGdldENTU1J1bGVzOiB0cnVlLFxuICAgIGdldENTU1NlbGVjdG9yczogdHJ1ZSxcbiAgICBnZXRDU1NQcm9wZXJ0aWVzOiB0cnVlLFxuICAgIGdldENTU1NlbGVjdG9yU3BlY2lmaWNpdHk6IHRydWVcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYW4gb3BlcmF0aW9uIG9uIGEgZ2l2ZW4gaGlnaGxpZ2h0ZXJcbiAqIEBwYXJhbSAge1N0cmluZ30gaGlnaGxpZ2h0ZXJJZCBcbiAqICAgICBJZGVudGlmaWVyIG9mIHRoZSBoaWdobGlnaHRlciBvbnRvIHdoaWNoIHRoZSBvcGVyYXRpb24gc2hvdWxkIGJlXG4gKiAgICAgZXhlY3V0ZWRcbiAqIEBwYXJhbSAge1N0cmluZ30gb3BlcmF0aW9uXG4gKiAgICAgTmFtZSBvZiB0aGUgb3BlcmF0aW9uIHRvIGJlIGV4ZWN1dGVkXG4gKiBAcGFyYW0gIHtBcnJheXwqfSBhcmdzXG4gKiAgICAgU2V0IG9mIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIG9wZXJhdGlvblxuICogQHJldHVybiB7Kn1cbiAqICAgICBSZXN1bHRzIG9mIHRoZSBvcGVyYXRpb24uIFdoYXRldmVyIHRoZSBvcGVyYXRpb24gcmV0dXJucy5cbiAqL1xuZXhwb3J0cy5leGVjdXRlSGlnaGxpZ2h0ZXJPcGVyYXRpb24gPSBmdW5jdGlvbiAoaGlnaGxpZ2h0ZXJJZCwgb3BlcmF0aW9uLCBhcmdzKSB7XG5cbiAgICAvLyByZXRyaWV2ZSB0aGUgaGlnaGxpZ2h0ZXIgb2JqZWN0XG4gICAgdmFyIGhpZ2hsaWdodGVyID0gdGhpcy5nZXRIaWdobGlnaHRlcihoaWdobGlnaHRlcklkKSB8fCB0aGlzLl9jYW52YXMuaGlnaGxpZ2h0ZXJzLmZvY3VzO1xuXG4gICAgaWYgKFdISVRFTElTVEVEX0hJR0hMSUdIVEVSX09QRVJBVElPTlNbb3BlcmF0aW9uXSkge1xuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0ZXJbb3BlcmF0aW9uXS5hcHBseShoaWdobGlnaHRlciwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb28gYmFkOiBoaWdobGlnaHRlciBvcGVyYXRpb24gYCcgKyBvcGVyYXRpb24gKyAnYCBub3Qgd2hpdGVsaXN0ZWQuIDooJylcbiAgICB9XG59OyIsIi8qKlxuICogRW5hYmxlcyBtZXNzYWdpbmcgYmV0d2VlbiBmcmFtZXNcbiAqL1xuXG52YXIgQ09OU1RBTlRTID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5cbi8qKlxuICogTWV0aG9kIGNhbGxlZCB3aGVuZXZlciB0aGUgY29tcG9uZW50IGlzIHJlYWR5XG4gKi9cbmV4cG9ydHMucmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTGlzdGVuIHRvIGBtZXNzYWdlYCBldmVudHMgb24gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgLy8gVGhlIHdpbmRvdyBpcyB0aGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHdob2xlIGFwcGxpY2F0aW9uLFxuICAgIC8vIGluIHRoZSBjYXNlIG9mIHRoZSBlZGl0ZWQgYXBwbGljYXRpb24gKGluc2lkZSB3aGljaCBpcyB0aGUgaW5zcGVjdG9yIGNvbXBvbmVudClcbiAgICAvLyBpdCBpcyB0aGUgYGlmcmFtZWAuIFxuICAgIC8vIFxuICAgIC8vIE9ubHkgdGhlIHdpbmRvdyByZWNlaXZlcyBtZXNzYWdlcy5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuaGFuZGxlRnJhbWVSZXF1ZXN0TWVzc2FnZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgbWVzc2FnZXMgZnJvbSB0aGUgcGFyZW50IGZyYW1lLlxuICogQHBhcmFtICB7RXZlbnR9IGV2ZW50IHRoZSBldmVudCBvYmplY3RcbiAqL1xuZXhwb3J0cy5oYW5kbGVGcmFtZVJlcXVlc3RNZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gbcOpdG9kbyBKU09OLnBhcnNlKCkgY29udmVydGUgc3RyaW5nIHBhcmEgSlNPTlxuICAgIHZhciByZXF1ZXN0ID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBvcGVyYXRpb25OYW1lIGlzIHdoaXRlbGlzdGVkXG4gICAgLy8gTm90IGFsbCBtZXRob2RzIG9uIHRoZSBpbnNwZWN0b3Igb2JqZWN0IHNob3VsZCBiZVxuICAgIC8vIGF2YWlsYWJsZSBmb3Igb3V0c2lkZSB1c2UgZm9yIHNlY3VyaXR5IHJlYXNvbnMuXG4gICAgLy8gVGh1cyB3ZSBzaG91bGQgd2hpdGVsaXN0IHRoZSBhdmFpbGFibGUgbWV0aG9kc1xuICAgIHZhciBvcGVyYXRpb25XaGl0ZWxpc3RlZCA9IENPTlNUQU5UUy5vcGVyYXRpb25XaGl0ZWxpc3RbcmVxdWVzdC5vcGVyYXRpb25dOyBcblxuICAgIGlmIChvcGVyYXRpb25XaGl0ZWxpc3RlZCkge1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBvcGVyYXRpb24gYW5kIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgICAgdmFyIHJlcyA9IHRoaXNbcmVxdWVzdC5vcGVyYXRpb25dLmFwcGx5KHRoaXMsIHJlcXVlc3QuYXJncyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHJlc3VsdCBpcyBhIHByb21pc2UsIHdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIGJlIFxuICAgICAgICAvLyBkb25lIGJlZm9yZSByZXR1cm5pbmcgcmVzdWx0c1xuICAgICAgICBRLndoZW4ocmVzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbmFsUmVzKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTZW5kIG1lc3NhZ2UgdG8gcGFyZW50IGZyYW1lIHBhc3NpbmcgdGhlIHJlcXVlc3QuaWRcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBwYXJlbnQgbWF5IHJlc29sdmUgdG8gdGhlIGNvcnJlY3QgaW5xdWlyeS5cbiAgICAgICAgICAgICAgICBwYXJlbnQucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBpZDogcmVxdWVzdC5pZCxcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIG1ldGhvZCB0byBjb252ZXJ0IHRoZSBvYmplY3QgaW50byBcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxhaW4gSlNPTiBvYmplY3QsIGRvIHNvLlxuICAgICAgICAgICAgICAgICAgICByZXM6IChmaW5hbFJlcyAhPT0gdW5kZWZpbmVkICYmIGZpbmFsUmVzLnRvUGxhaW5PYmplY3QpID8gZmluYWxSZXMudG9QbGFpbk9iamVjdCgpIDogZmluYWxSZXNcbiAgICAgICAgICAgICAgICB9KSwgJyonKTtcblxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLy8gdGVybWluYXRlIHByb21pc2UgY2hhaW5cbiAgICAgICAgICAgIC5kb25lKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiAlcyBpcyBub3QgYXZhaWxhYmxlIGF0IGluc3BlY3RvcicsIHJlcXVlc3Qub3BlcmF0aW9uKTtcbiAgICB9XG59OyIsIi8qKlxuICogQGNsYXNzIENTU0luc3BlY3RvclxuICpcbiAqIERlZmluZXMgYSBjbGFzcyBmb3IgaW5zcGVjdGluZyBjc3MgcnVsZXMgYW5kIHN0eWxlc2hlZXRzXG4gKiBhbmQgdGhlaXIgZWZmZWN0cyBvbiB0YXJnZXQgZWxlbWVudHMuXG4gKlxuICogRm9yIHRoZSB0aW1lIGJlaW5nLCBkb2VzIG5vdCBwZXJmb3JtIGFueSBpbnRlbGxpZ2VuY2UsXG4gKiBpdCBkZWxlZ2F0ZXMgdG8gQ1NTVXRpbGl0aWVzIChieSBicm90aGVyY2FrZSkuXG4gKiBcbiAqIEZvciBkb2NzIG9uIENTU1V0aWxpdGllczpcbiAqIC8vIGh0dHA6Ly93d3cuYnJvdGhlcmNha2UuY29tL3NpdGUvcmVzb3VyY2VzL3NjcmlwdHMvY3NzdXRpbGl0aWVzL2Z1bmN0aW9uc1xuICovXG5cbi8qKlxuICogQ2xhc3MgdGhhdCBwcm94aWVzIG1ldGhvZHMgdG8gQ1NTVXRpbGl0aWVzXG4gKiBAcGFyYW0ge05vZGV9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdGhlIGluc3BlY3RvciBzaG91bGQgd29yayB1cG9uXG4gKi9cbmZ1bmN0aW9uIENTU0luc3BlY3RvcihkZWZhdWx0T3B0aW9ucywgZWxlbWVudCkge1xuXG4gICAgLy8gU2F2ZSB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuXG4gICAgdGhpcy5zZXRUYXJnZXQoZWxlbWVudCk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7W3R5cGVdfSBlbGVtZW50IFtkZXNjcmlwdGlvbl1cbiAqL1xuQ1NTSW5zcGVjdG9yLnByb3RvdHlwZS5zZXRUYXJnZXQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMudGFyZ2V0ID0gZWxlbWVudDtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBgZ2V0Q1NTUnVsZXNgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgR0VUX0NTU19SVUxFU19ERUZBVUxUUyA9IHtcbiAgICBtZWRpYTogJ3NjcmVlbicsXG4gICAgcHJvcGVydGllczogWydwcm9wZXJ0aWVzJywgJ3NlbGVjdG9yJywgJ2NzcyddLFxuICAgIGFsdHN0YXRlczogdHJ1ZSxcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBydWxlcyB0aGF0IGFwcGx5IHRvIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gIHtbdHlwZV19IG9wdGlvbnMgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7UHJvbWlzZSAtPiBBcnJheX0gICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbkNTU0luc3BlY3Rvci5wcm90b3R5cGUuZ2V0Q1NTUnVsZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmICghdGhpcy50YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0YXJnZXQgZm9yIGBnZXRDU1NSdWxlc2AnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRGVmYXVsdCBzZXR0aW5nXG4gICAgb3B0aW9ucyA9IF8uYXNzaWduKHt9LCBHRVRfQ1NTX1JVTEVTX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgICAvLyBjcmVhdGUgYSBkZWZlciBvYmplY3RcbiAgICB2YXIgZGVmZXIgPSBRLmRlZmVyKCk7XG4gICAgXG4gICAgLy8gcHJvcGVydGllcyBvcHRpb24gbXVzdCBiZSBTdHJpbmdcbiAgICB2YXIgcHJvcGVydGllcyA9IF8uaXNBcnJheShvcHRpb25zLnByb3BlcnRpZXMpID8gXG4gICAgICAgIG9wdGlvbnMucHJvcGVydGllcy5qb2luKCcsJykgOiBcbiAgICAgICAgb3B0aW9ucy5wcm9wZXJ0aWVzO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ1NTVXRpbGl0aWVzLmdldENTU1J1bGVzKGVsZW1lbnQgWywgbWVkaWFdIFssIHByb3BlcnRpZXNdIFssIGFsdHN0YXRlc10gWywgb25jb21wbGV0ZV0pXG4gICAgICAgIENTU1V0aWxpdGllcy5nZXRDU1NSdWxlcyhcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LCBcbiAgICAgICAgICAgIG9wdGlvbnMubWVkaWEsIFxuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIG9wdGlvbnMuYWx0c3RhdGVzLFxuICAgICAgICAgICAgZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShydWxlcy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiByLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzOiByLmNzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHIucHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWZlci5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRoZSBwcm9taXNlXG4gICAgcmV0dXJuIGRlZmVyLnByb21pc2U7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgYGdldENTU1Byb3BlcnRpZXNgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgR0VUX0NTU19QUk9QRVJUSUVTX0RFRkFVTFRTID0ge1xuICAgIG1lZGlhOiAnc2NyZWVuJyxcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGNzcyBwcm9wZXJ0aWVzIHJlbGF0ZWQgdG8gdGhlIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7UHJvbWlzZSAtPiBBcnJheX1cbiAqL1xuQ1NTSW5zcGVjdG9yLnByb3RvdHlwZS5nZXRDU1NQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMudGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdGFyZ2V0IGZvciBgZ2V0Q1NTUHJvcGVydGllc2AnKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHNldHRpbmdcbiAgICBvcHRpb25zID0gXy5hc3NpZ24oe30sIEdFVF9DU1NfUFJPUEVSVElFU19ERUZBVUxUUywgb3B0aW9ucyk7XG4gICAgLy8gY3JlYXRlIGEgZGVmZXIgb2JqZWN0XG4gICAgdmFyIGRlZmVyID0gUS5kZWZlcigpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ1NTVXRpbGl0aWVzLmdldENTU1Byb3BlcnRpZXMoZWxlbWVudCBbLCBtZWRpYV0gWywgb25jb21wbGV0ZV0pXG4gICAgICAgIENTU1V0aWxpdGllcy5nZXRDU1NQcm9wZXJ0aWVzKFxuICAgICAgICAgICAgdGhpcy50YXJnZXQsIFxuICAgICAgICAgICAgb3B0aW9ucy5tZWRpYSwgXG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlXG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWZlci5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRoZSBwcm9taXNlXG4gICAgcmV0dXJuIGRlZmVyLnByb21pc2U7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgZ2V0Q1NTU2VsZWN0b3JzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgR0VUX0NTU19TRUxFQ1RPUlNfREVGQVVMVFMgPSB7XG4gICAgbWVkaWE6ICdzY3JlZW4nLFxuICAgIGRpcmVjdG9ubHk6IHRydWUsXG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBjc3Mgc2VsZWN0b3JzIHRoYXQgYXBwbHkgdG8gdGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIFxuICogQHJldHVybiB7UHJvbWlzZSAtPiBBcnJheX1cbiAqICAgICBUYWtlbiBmcm9tIENTU1V0aWxpdGllcyBkb2NzXG4gKiAgICAgXCJUaGUgbWV0aG9kIHJldHVybnMgYW4gYXJyYXkgb2YgemVybyBvciBtb3JlIHNlbGVjdG9ycyxcbiAqICAgICBlYWNoIG9mIHdoaWNoIGlzIGEgU3RyaW5nIENTUyBzZWxlY3RvcixcbiAqICAgICB0cmltbWVkIG9mIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZS5cIlxuICovXG5DU1NJbnNwZWN0b3IucHJvdG90eXBlLmdldENTU1NlbGVjdG9ycyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLnRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tDU1NJbnNwZWN0b3JdIE5vIHRhcmdldCBmb3IgYGdldENTU1NlbGVjdG9yc2AnKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHNldHRpbmdcbiAgICBvcHRpb25zID0gXy5hc3NpZ24oe30sIEdFVF9DU1NfU0VMRUNUT1JTX0RFRkFVTFRTLCBvcHRpb25zKTtcblxuICAgIHZhciBkZWZlciA9IFEuZGVmZXIoKTtcbiAgICAvLyBDU1NVdGlsaXRpZXMuZ2V0Q1NTU2VsZWN0b3JzKGVsZW1lbnQgWywgbWVkaWFdIFssIGRpcmVjdG9ubHldIFssIG9uY29tcGxldGVdKVxuICAgIFxuICAgIC8vIFRPRE86IHN0dWR5IGVycm9yIGhhbmRsaW5nIHdpdGggQ1NTVXRpbGl0aWVzXG4gICAgLy8gSXRzIGFzeW5jaHJvbm91cyBhcGkgc2hvdWxkIG5vdCBiZSBkZWFsdCB3aXRoIHRyeS1jYXRjaFxuICAgIC8vIGJ1dCBpbnN0ZWFkIHNvbWUgd2F5IG9mIGVycm9yIGhhbmRsaW5nIG9uIHRoZSBjYWxsYmFjay5cbiAgICAvLyBCdXQgdGhlIGNvcnJlY3QgZXJyb3IgaGFuZGxpbmcgbW9kZSB3YXMgbm90IGZvdW5kIHVudGlsIG5vdyBcbiAgICAvLyAoanVzdCBzdGFydGluZyBleHBlcmltZW50KVxuICAgIHRyeSB7XG4gICAgICAgIENTU1V0aWxpdGllcy5nZXRDU1NTZWxlY3RvcnMoXG4gICAgICAgICAgICB0aGlzLnRhcmdldCwgXG4gICAgICAgICAgICBvcHRpb25zLm1lZGlhLCBcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0b25seSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChzZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHNlbGVjdG9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWZlci5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmVyLnByb21pc2U7XG59O1xuXG5cbi8qKlxuICogUmV0cmlldmVzIHNlbGVjdG9yIHNwZWNpZmljaXR5IGZvciBhIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSAge1t0eXBlXX0gb3B0aW9ucyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5DU1NJbnNwZWN0b3IucHJvdG90eXBlLmdldENTU1NlbGVjdG9yU3BlY2lmaWNpdHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmICghdGhpcy50YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQ1NTSW5zcGVjdG9yXSBObyB0YXJnZXQgZm9yIGBnZXRDU1NTZWxlY3RvclNwZWNpZmljaXR5YCcpO1xuICAgIH1cbiAgICAvLyBDU1NVdGlsaXRpZXMuZ2V0Q1NTU2VsZWN0b3JTcGVjaWZpY2l0eShzZWxlY3RvciBbLCBlbGVtZW50XSBbLCBvbmNvbXBsZXRlXSlcbn07XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZHNcbiAqL1xuXG5DU1NJbnNwZWN0b3IuZ2V0Q1NTU2VsZWN0b3JTcGVjaWZpY2l0eSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gQ1NTVXRpbGl0aWVzLmdldENTU1NlbGVjdG9yU3BlY2lmaWNpdHkoc2VsZWN0b3IgWywgZWxlbWVudF0gWywgb25jb21wbGV0ZV0pXG59O1xuQ1NTSW5zcGVjdG9yLmdldENTU1N0eWxlU2hlZXRSdWxlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gQ1NTVXRpbGl0aWVzLmdldENTU1N0eWxlU2hlZXRSdWxlcyhbbWVkaWFdIFssIGFjY2VwdF0gWywgc3NpZF0gWywgb25jb21wbGV0ZV0pXG59O1xuQ1NTSW5zcGVjdG9yLmdldENTU1N0eWxlU2hlZXRzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIENTU1V0aWxpdGllcy5nZXRDU1NTdHlsZVNoZWV0cyhbb25jb21wbGV0ZV0pXG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIENTU1V0aWxpdGllc1xuICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVDU1NVdGlsaXRpZXMoKSB7XG4gICAgLy8gQ1NTVXRpbGl0aWVzIGlzIGF2YWlsYWJsZSBhcyBhIGdsb2JhbFxuICAgIC8vIGFzIGl0IHdhcyBpbXBvcnRlZCB2aWEgYHNjcmlwdGAgdGFnXG4gICAgXG4gICAgLy8gc2V0IGNvbmZpZyBhbmQgaW5pdGlhbGl6ZVxuICAgIC8vIFVzZSBhdXRob3IgbW9kZSBiZWNhdXNlIHdlIG5lZWQgdG8gYWNjZXNzIHRoZSBhY3R1YWwgXG4gICAgLy8gc3R5bGVzaGVldHMuXG4gICAgLy8gXG4gICAgLy8gVGhpcyBpbmN1cnMgaW4gb25lIGV4dHJhIGFqYXggZ2V0IHJlcXVlc3QgXG4gICAgLy8gZm9yIGVhY2ggc3R5bGVzaGVldCBpbiB0aGUgaW5zcGVjdGVkIGFwcGxpY2F0aW9uLlxuICAgIC8vIFxuICAgIC8vIEFsc28sIHNvbWUgbWV0aG9kcyB3aWxsIHJ1biBpbiBhc3luY2hyb25vdXMgbW9kZSwgXG4gICAgLy8gd2l0aCBjYWxsYmFja3MuXG4gICAgLy8gXG4gICAgLy8gZG9jczpcbiAgICAvLyBodHRwOi8vd3d3LmJyb3RoZXJjYWtlLmNvbS9zaXRlL3Jlc291cmNlcy9zY3JpcHRzL2Nzc3V0aWxpdGllcy9jb25maWcvI2NvbmZpZy1tb2RlXG4gICAgQ1NTVXRpbGl0aWVzLmRlZmluZSgnbW9kZScsICdicm93c2VyJyk7XG4gICAgQ1NTVXRpbGl0aWVzLmRlZmluZSgnYXN5bmMnLCB0cnVlKTtcbiAgICAvLyBEbyBub3QgdGFrZSBpbnRvIGFjY291bnQgaW5saW5lIHN0eWxlc1xuICAgIENTU1V0aWxpdGllcy5kZWZpbmUoJ2F0dHJpYnV0ZXMnLCBmYWxzZSk7XG4gICAgQ1NTVXRpbGl0aWVzLmluaXQoKTtcbn1cblxuLy8gaW52b2tlIENTU1V0aWxpdGllcyBpbml0aWFsaXphdGlvbiBpbW1lZGlhdGVseVxuaW5pdGlhbGl6ZUNTU1V0aWxpdGllcygpO1xuXG4vLyBleHBvcnRcbm1vZHVsZS5leHBvcnRzID0gQ1NTSW5zcGVjdG9yOyIsIi8qKlxuICogQ2xhc3MgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgZW5jYXBzdWxhdGluZyBzY29wZSBcbiAqIGZvciBlYWNoIG9mIHRoZSBoaWdobGlnaHRlciBlbGVtZW50cyB3aXRoaW4uXG4gKi9cblxudmFyIENPTlNUQU5UUyAgICAgID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG52YXIgaGlnaGxpZ2h0ZXJzTnMgPSBDT05TVEFOVFMuaGlnaGxpZ2h0ZXJzTnM7XG5cbnZhciBET01IZWxwZXJzID0gcmVxdWlyZSgnLi4vYXV4L2RvbScpO1xuXG5cbi8vIExvYWQgaW50ZXJuYWwgZGVwZW5kZW5jaWVzXG52YXIgQ1NTSW5zcGVjdG9yID0gcmVxdWlyZSgnLi9jc3MtaW5zcGVjdG9yJyk7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIHRoZSBjYXJiby1oaWdobGlnaHRlciBlbGVtZW50XG4gKiB2aXJ0dWFsbHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIERhdGEgdG8gYmUgc2V0IG9uIHRoZSBzY29wZVxuICogQHBhcmFtIHs8Y2FyYm8taW5zcGVjdG9yPn0gW2luc3BlY3Rvcl0gVGhlIGluc3BlY3RvciBpbnN0YW5jZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGhpZ2hsaWdodGVyIGlzIG93bmVkIGJ5LlxuICovXG5mdW5jdGlvbiBIaWdobGlnaHRlclNjb3BlKGRhdGEsIGluc3BlY3Rvcikge1xuXG4gICAgdGhpcy5pZCA9IF8udW5pcXVlSWQoJ2hpZ2hsaWdodGVyXycpO1xuXG4gICAgLy8ga2VlcCByZWZlcmVuY2UgdG8gdGhlIGluc3BlY3RvciBpbnN0YW5jZVxuICAgIHRoaXMuaW5zcGVjdG9yID0gaW5zcGVjdG9yO1xuXG4gICAgLy8gR2V0IGFsbCBkYXRhXG4gICAgXy5hc3NpZ24odGhpcywgZGF0YSk7XG5cbiAgICAvLyBpbnN0YW50aWF0ZSBhIENTU0luc3BlY3RvclxuICAgIHRoaXMuX2Nzc0luc3BlY3RvciA9IG5ldyBDU1NJbnNwZWN0b3IoKTtcbn1cblxuLyoqXG4gKiBQcm94aWVzIDxjYXJiby1oaWdobGlnaHRlcj4uaGlnaGxpZ2h0IG1ldGhvZFxuICogQHBhcmFtICB7Tm9kZX0gZWxlbWVudCBOb2RlIHRvIGJlIGhpZ2hsaWdodGVkXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgXG4gKi9cbkhpZ2hsaWdodGVyU2NvcGUucHJvdG90eXBlLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG5cbiAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgZm9yIEhpZ2hsaWdodGVyU2NvcGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldCgnZWxlbWVudExhYmVsJywgZWxlbWVudC50YWdOYW1lKTtcblxuICAgIHRoaXMuZWxlbWVudC5oaWdobGlnaHQoZWxlbWVudCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFByb3hpZXMgdGhlIDxjYXJiby1oaWdobGlnaHRlcj4uaGlkZSBtZXRob2RcbiAqL1xuSGlnaGxpZ2h0ZXJTY29wZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgZm9yIEhpZ2hsaWdodGVyU2NvcGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuaGlkZSgpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIHNldCBkYXRhIHVzaW5nIHBvbHltZXIgc3R1ZmZcbiAqL1xuSGlnaGxpZ2h0ZXJTY29wZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuXG4gICAgdmFyIHBhdGggPSBoaWdobGlnaHRlcnNOcyArICcuJyArIHRoaXMuaW5kZXggKyAnLicgKyBwcm9wZXJ0eTtcblxuICAgIHRoaXMuaW5zcGVjdG9yLnNldChwYXRoLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBkYXRhIGFib3V0IHRoZSBlbGVtdG5cbiAqIEByZXR1cm4ge09iamVjdH0gW2Rlc2NyaXB0aW9uXVxuICovXG5IaWdobGlnaHRlclNjb3BlLnByb3RvdHlwZS5nZXRUYXJnZXREYXRhID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZWxlbWVudC50YXJnZXQ7XG4gICAgdmFyIGRhdGE7XG5cbiAgICBpZiAodGFyZ2V0KSB7XG5cbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgdGFnTmFtZTogdGFyZ2V0LnRhZ05hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBET01IZWxwZXJzLmdldEF0dHJpYnV0ZXModGFyZ2V0KSxcbiAgICAgICAgICAgIGNvbXB1dGVkU3R5bGU6IERPTUhlbHBlcnMuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLFxuICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgIHRvcDogYm91bmRpbmdSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBzY29wZSBkYXRhIGludG8gYSBwbGFpbiBvYmplY3QgcmVhZHkgZm9yIFxuICogSlNPTiBzdHJpbmdpZmljYXRpb25cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuSGlnaGxpZ2h0ZXJTY29wZS5wcm90b3R5cGUudG9QbGFpbk9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBvYmogPSB7XG4gICAgICAgIGlkOiB0aGlzLmlkXG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBEZWZpbmUgdGhlIGluZGV4IHByb3BlcnR5XG4gKiB3aGljaCB3aWxsIGp1c3QgcG9pbnQgdG8gdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBoaWdobGlnaHRlciBzY29wZVxuICogaXMgc3RvcmVkIGF0IHRoZSBpbnNwZWN0b3Igb2JqZWN0LlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSGlnaGxpZ2h0ZXJTY29wZS5wcm90b3R5cGUsICdpbmRleCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgX2hpZ2hsaWdodGVycyA9IHRoaXMuaW5zcGVjdG9yW0NPTlNUQU5UUy5oaWdobGlnaHRlcnNOc107IFxuXG4gICAgICAgIHJldHVybiBfLmluZGV4T2YoX2hpZ2hsaWdodGVycywgdGhpcyk7XG4gICAgfSxcbn0pO1xuXG5cblxuLyoqXG4gKiBDU1NJbnNwZWN0b3IgcHJveHkgbWV0aG9kc1xuICovXG52YXIgQ1NTX0lOU1BFQ1RPUl9QUk9YWV9NRVRIT0RTID0gW1xuICAgICdnZXRDU1NSdWxlcycsXG4gICAgJ2dldENTU1NlbGVjdG9ycycsXG4gICAgJ2dldENTU1Byb3BlcnRpZXMnLFxuICAgICdnZXRDU1NTZWxlY3RvclNwZWNpZmljaXR5Jyxcbl07XG5cbkNTU19JTlNQRUNUT1JfUFJPWFlfTUVUSE9EUy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgSGlnaGxpZ2h0ZXJTY29wZS5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvLyBzZXQgdGhlIHRhcmdldCBvZiB0aGUgX2Nzc0luc3BlY3RvclxuICAgICAgICB0aGlzLl9jc3NJbnNwZWN0b3Iuc2V0VGFyZ2V0KHRoaXMuZWxlbWVudC50YXJnZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY3NzSW5zcGVjdG9yW21ldGhvZE5hbWVdKG9wdGlvbnMpO1xuICAgIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBIaWdobGlnaHRlclNjb3BlOyIsIi8qKlxuICogTGlzdCBvZiBvcGVyYXRpb25zIHRoYXQgY2FuIGJlIGNhbGxlZCB2aWEgd2luZG93LnBvc3RNZXNzYWdlXG4gKiBmcm9tIHRoZSBvdXRlciB3b3JsZC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMub3BlcmF0aW9uV2hpdGVsaXN0ID0ge1xuICAgICdoaWdobGlnaHRFbGVtZW50QXRQb2ludCc6IHRydWUsXG4gICAgJ3VuSGlnaGxpZ2h0JzogdHJ1ZSxcbiAgICAnZ2V0QWN0aXZlRWxlbWVudERhdGEnOiB0cnVlLFxuICAgICdzY3JvbGxCeSc6IHRydWUsXG4gICAgJ2FyZUZvY3VzQW5kSG92ZXJUb2dldGhlcic6IHRydWUsXG4gICAgJ2FjdGl2YXRlTG9hZGluZyc6IHRydWUsXG4gICAgJ2RlYWN0aXZhdGVMb2FkaW5nJzogdHJ1ZSxcbiAgICAnZXhlY3V0ZUhpZ2hsaWdodGVyT3BlcmF0aW9uJzogdHJ1ZVxufTtcblxuLyoqXG4gKiBOYW1lIG9mIHRoZSBwcm9wZXJ0eSBhdCB3aGljaCBoaWdobGlnaGVycyB3aWxsIGJlIHN0b3JlZC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuaGlnaGxpZ2h0ZXJzTnMgPSAnX2hpZ2hsaWdodGVycyc7XG4iXX0=
</script>

</dom-module></body></html>